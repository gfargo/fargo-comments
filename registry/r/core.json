{
  "name": "fargo-comments-core",
  "type": "registry:lib",
  "dependencies": [
    "@emoji-mart/data@latest",
    "@lexical/link@latest",
    "@lexical/list@latest",
    "@lexical/react@latest",
    "@lexical/utils@latest",
    "class-variance-authority@^0.7.1",
    "clsx@^2.1.1",
    "date-fns@4.1.0",
    "emoji-mart@latest",
    "lexical@latest",
    "lexical-beautiful-mentions@latest",
    "lucide-react@^0.454.0",
    "tailwind-merge@^2.5.5"
  ],
  "files": [
    {
      "type": "registry:lib",
      "path": "lib/adapters/comment-storage-adapter.ts",
      "content": "import type { Comment, CommentThread, User, MentionUser, MentionTag } from \"@/lib/comments/types/comments\"\n\nexport interface CommentStorageAdapter {\n  // Comment operations\n  getComments(): Promise<Comment[]>\n  saveComments(comments: Comment[]): Promise<void>\n  addComment(comment: Comment): Promise<void>\n  updateComment(commentId: string, updates: Partial<Comment>): Promise<void>\n  deleteComment(commentId: string): Promise<void>\n\n  addLexicalComment(\n    content: string,\n    editorState: string,\n    author: User,\n    mentions?: MentionUser[],\n    tags?: MentionTag[],\n    sourceId?: string,\n    sourceType?: string,\n    parentId?: string,\n  ): Promise<Comment>\n\n  updateCommentWithEditorState(\n    commentId: string,\n    content: string,\n    editorState: string,\n    mentions?: MentionUser[],\n    tags?: MentionTag[],\n  ): Promise<void>\n\n  getcommentsSource(sourceId: string, sourceType?: string): Promise<Comment[]>\n  getCommentThreads(sourceId?: string, sourceType?: string): Promise<CommentThread[]>\n\n  // Utility operations\n  clearAllStorage(): Promise<void>\n}\n\nexport interface StorageAdapterConfig {\n  // For server-side adapters\n  apiEndpoint?: string\n  headers?: Record<string, string>\n\n  // For database adapters\n  connectionString?: string\n\n  // For demo/development\n  enableDemoData?: boolean\n\n  // Custom configuration\n  [key: string]: string | boolean | undefined | Record<string, string>\n}\n"
    },
    {
      "type": "registry:lib",
      "path": "lib/adapters/index.ts",
      "content": "import type { CommentStorageAdapter, StorageAdapterConfig } from \"./comment-storage-adapter\"\nimport { LocalStorageAdapter } from \"./local-storage-adapter\"\nimport { ServerActionAdapter } from \"./server-action-adapter\"\nimport { CachedServerActionAdapter, type ServerActionSet, type CachedServerActionAdapterConfig } from \"./cached-server-action-adapter\"\nimport { ApiAdapter } from \"./api-adapter\"\nimport { useTanstackQueryAdapter } from \"./tanstack-query-adapter\"\n\nexport type { CommentStorageAdapter, StorageAdapterConfig, ServerActionSet, CachedServerActionAdapterConfig }\nexport { LocalStorageAdapter }\nexport { ServerActionAdapter }\nexport { CachedServerActionAdapter }\nexport { ApiAdapter }\nexport { useTanstackQueryAdapter }\n\nexport function createStorageAdapter(\n  type: \"localStorage\" | \"serverActions\" | \"cachedServerActions\" | \"api\" | \"custom\",\n  config: StorageAdapterConfig | CachedServerActionAdapterConfig = {},\n  customAdapter?: CommentStorageAdapter,\n): CommentStorageAdapter {\n  switch (type) {\n    case \"localStorage\":\n      return new LocalStorageAdapter(config)\n    case \"serverActions\":\n      return new ServerActionAdapter(config)\n    case \"cachedServerActions\":\n      return new CachedServerActionAdapter(config as CachedServerActionAdapterConfig)\n    case \"api\":\n      return new ApiAdapter(config)\n    case \"custom\":\n      if (!customAdapter) {\n        throw new Error(\"Custom adapter must be provided when type is 'custom'\")\n      }\n      return customAdapter\n    default:\n      throw new Error(`Unknown adapter type: ${type}`)\n  }\n}\n"
    },
    {
      "type": "registry:lib",
      "path": "lib/adapters/local-storage-adapter.ts",
      "content": "import type {\n    Comment,\n    CommentThread,\n    User,\n    MentionUser,\n    MentionTag,\n} from \"@/lib/comments/types/comments\";\nimport type {\n    CommentStorageAdapter,\n    StorageAdapterConfig,\n} from \"./comment-storage-adapter\";\nimport { generateId } from \"@/lib/comments/utils/generateId\";\nimport { extractMentionsAndTags } from \"@/lib/comments/lexical-utils\";\nimport { debug } from \"@/lib/comments/utils/debug\";\n\nexport class LocalStorageAdapter implements CommentStorageAdapter {\n  private readonly STORAGE_KEYS = {\n    COMMENTS: \"fargo_comment_store\",\n  } as const;\n\n  constructor(private config: StorageAdapterConfig = {}) {}\n\n  async getComments(): Promise<Comment[]> {\n    if (typeof window === \"undefined\") return [];\n    const stored = localStorage.getItem(this.STORAGE_KEYS.COMMENTS);\n    if (!stored) return [];\n\n    const comments = JSON.parse(stored);\n    return comments.map((comment: Comment) => ({\n      ...comment,\n      createdAt: new Date(comment.createdAt),\n      updatedAt: new Date(comment.updatedAt),\n    }));\n  }\n\n  async saveComments(comments: Comment[]): Promise<void> {\n    if (typeof window === \"undefined\") return;\n    localStorage.setItem(this.STORAGE_KEYS.COMMENTS, JSON.stringify(comments));\n  }\n\n  async addComment(comment: Comment): Promise<void> {\n    const comments = await this.getComments();\n    comments.push({\n      ...comment,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    });\n    await this.saveComments(comments);\n  }\n\n  async updateComment(\n    commentId: string,\n    updates: Partial<Comment>\n  ): Promise<void> {\n    const comments = await this.getComments();\n    const index = comments.findIndex((c) => c.id === commentId);\n    if (index !== -1) {\n      comments[index] = {\n        ...comments[index],\n        ...updates,\n        updatedAt: new Date(),\n        isEdited: true,\n      };\n      await this.saveComments(comments);\n    }\n  }\n\n  async deleteComment(commentId: string): Promise<void> {\n    const comments = await this.getComments();\n    const filtered = comments.filter((c) => c.id !== commentId);\n    await this.saveComments(filtered);\n  }\n\n  async addLexicalComment(\n    content: string,\n    editorState: string,\n    author: User,\n    mentions: MentionUser[] = [],\n    tags: MentionTag[] = [],\n    sourceId?: string,\n    sourceType?: string,\n    parentId?: string\n  ): Promise<Comment> {\n    const extracted = extractMentionsAndTags(editorState);\n    const finalMentions = mentions.length > 0 ? mentions : extracted.mentions;\n    const finalTags = tags.length > 0 ? tags : extracted.tags;\n\n    const comment: Comment = {\n      id: generateId(),\n      content,\n      editorState,\n      authorId: author.id,\n      author,\n      sourceId,\n      sourceType,\n      parentId,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      isEdited: false,\n      mentions: finalMentions,\n      tags: finalTags,\n      reactions: [],\n      status: \"active\",\n    };\n\n    await this.addComment(comment);\n    debug.log(\"Comment added to storage:\", comment);\n    return comment;\n  }\n\n  async updateCommentWithEditorState(\n    commentId: string,\n    content: string,\n    editorState: string,\n    mentions?: MentionUser[],\n    tags?: MentionTag[]\n  ): Promise<void> {\n    const comments = await this.getComments();\n    const index = comments.findIndex((c) => c.id === commentId);\n    if (index !== -1) {\n      const extracted = extractMentionsAndTags(editorState);\n      const finalMentions = mentions || extracted.mentions;\n      const finalTags = tags || extracted.tags;\n\n      comments[index] = {\n        ...comments[index],\n        content,\n        editorState,\n        mentions: finalMentions,\n        tags: finalTags,\n        updatedAt: new Date(),\n        isEdited: true,\n      };\n      await this.saveComments(comments);\n    }\n  }\n\n  async getcommentsSource(\n    sourceId: string,\n    sourceType?: string\n  ): Promise<Comment[]> {\n    const comments = await this.getComments();\n    return comments.filter((c) => {\n      if (sourceType) {\n        return c.sourceId === sourceId && c.sourceType === sourceType;\n      }\n      return c.sourceId === sourceId;\n    });\n  }\n\n  async getCommentThreads(\n    sourceId?: string,\n    sourceType?: string\n  ): Promise<CommentThread[]> {\n    const comments = sourceId\n      ? await this.getcommentsSource(sourceId, sourceType)\n      : await this.getComments();\n\n    const rootComments = comments.filter((c) => !c.parentId);\n\n    return rootComments.map((rootComment) => {\n      const replies = comments.filter((c) => c.parentId === rootComment.id);\n      return {\n        id: rootComment.id,\n        rootComment,\n        replies,\n        totalReplies: replies.length,\n        lastActivity:\n          replies.length > 0\n            ? new Date(Math.max(...replies.map((r) => r.createdAt.getTime())))\n            : rootComment.createdAt,\n      };\n    });\n  }\n\n  async clearAllStorage(): Promise<void> {\n    if (typeof window === \"undefined\") return;\n    localStorage.removeItem(this.STORAGE_KEYS.COMMENTS);\n  }\n}\n"
    },
    {
      "type": "registry:lib",
      "path": "lib/comment-events.ts",
      "content": "\"use client\"\n\nimport React from \"react\";\n\nimport type { Comment, CommentReaction, User } from \"@/lib/comments/types/comments\";\n\n// Event types that can be emitted\nexport interface CommentEventMap {\n  \"comment:added\": { comment: Comment; user: User }\n  \"comment:updated\": { comment: Comment; previousContent: string; user: User }\n  \"comment:deleted\": { commentId: string; user: User }\n  \"reaction:added\": { commentId: string; reaction: CommentReaction; user: User }\n  \"reaction:removed\": { commentId: string; reactionId: string; user: User }\n  \"comments:loaded\": { comments: Comment[] }\n  \"comments:cleared\": { user: User }\n  error: { error: string; action?: string }\n}\n\n// Event listener type\nexport type CommentEventListener<T extends keyof CommentEventMap> = (\n  data: CommentEventMap[T]\n) => void\n\n// Event emitter class for comment system\nexport class CommentEventEmitter {\n  private listeners: Map<\n    keyof CommentEventMap,\n    Set<CommentEventListener<keyof CommentEventMap>>\n  > = new Map()\n\n  // Subscribe to an event\n  on<T extends keyof CommentEventMap>(\n    event: T,\n    listener: CommentEventListener<T>\n  ): () => void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set())\n    }\n\n    this.listeners.get(event)!.add(listener as CommentEventListener<keyof CommentEventMap>)\n\n    // Return unsubscribe function\n    return () => {\n      this.listeners.get(event)?.delete(listener as CommentEventListener<keyof CommentEventMap>)\n    }\n  }\n\n  // Emit an event\n  emit<T extends keyof CommentEventMap>(event: T, data: CommentEventMap[T]): void {\n    const eventListeners = this.listeners.get(event)\n    if (eventListeners) {\n      eventListeners.forEach((listener) => {\n        try {\n          listener(data)\n        } catch (error) {\n          console.error(`Error in comment event listener for ${event}:`, error)\n        }\n      })\n    }\n  }\n\n  // Remove all listeners for an event\n  off<T extends keyof CommentEventMap>(event: T): void {\n    this.listeners.delete(event)\n  }\n\n  // Remove all listeners\n  removeAllListeners(): void {\n    this.listeners.clear()\n  }\n\n  // Get listener count for debugging\n  getListenerCount<T extends keyof CommentEventMap>(event: T): number {\n    return this.listeners.get(event)?.size || 0\n  }\n}\n\n// Create a singleton instance for the comment system\nexport const commentEvents = new CommentEventEmitter()\n\n// Helper hook for subscribing to events in React components\nexport function useCommentEvent<T extends keyof CommentEventMap>(\n  event: T,\n  listener: CommentEventListener<T>\n): void {\n  React.useEffect(() => {\n    const unsubscribe = commentEvents.on(event, listener)\n    return unsubscribe\n  }, [event, listener])\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/comments/comment-action-bar.tsx",
      "content": "\"use client\";\n\nimport { useState } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Heart,\n  MessageCircle,\n  Edit,\n  Trash2,\n  BookText,\n  X,\n  ThumbsUp,\n  Share2Icon,\n  ForwardIcon,\n  CheckCircle2Icon,\n  MessageCircleXIcon,\n} from \"lucide-react\";\nimport { DeleteConfirmationDialog } from \"@/lib/comments/components/comments/delete-confirmation-dialog\";\nimport type { Comment, User as UserType } from \"@/lib/comments/types/comments\";\nimport { type CommentVariant } from \"@/lib/comments/types/comments\";\n\ninterface CommentActionBarProps {\n  comment: Comment;\n  currentUser: UserType;\n  variant: CommentVariant;\n  isReply: boolean;\n  isEditing: boolean;\n  isOwner: boolean;\n  isReplyingTo?: boolean;\n  onEdit?: (commentId: string, content: string, editorState: string) => void;\n  onDelete?: () => void;\n  onReply?: () => void;\n  onReplyCancel?: () => void;\n  onLike?: () => void;\n  onShare?: () => void;\n  onForward?: () => void;\n  onApprove?: () => void;\n  onReact?: (reaction: string) => void;\n  onToggleEdit?: () => void;\n  replies?: Comment[];\n}\n\nexport function CommentActionBar({\n  comment,\n  currentUser,\n  variant,\n  isReply,\n  isEditing,\n  isOwner,\n  isReplyingTo = false,\n  onEdit,\n  onDelete,\n  onReply,\n  onReplyCancel,\n  onLike,\n  onShare,\n  onForward,\n  onApprove,\n  onReact,\n  onToggleEdit,\n  replies = [],\n}: CommentActionBarProps) {\n  // The `currentUser`, `isReply`, and `onEdit` props are passed for consistency with other variants,\n  // but are not used in this component.\n  if (currentUser && isReply && onEdit) {\n    // do nothing\n  }\n  const [showReferences, setShowReferences] = useState(false);\n  const [showDeleteDialog, setShowDeleteDialog] = useState(false);\n\n  const handleDeleteClick = () => {\n    setShowDeleteDialog(true);\n  };\n\n  const handleConfirmDelete = () => {\n    onDelete?.();\n    setShowDeleteDialog(false);\n  };\n\n  const getActionBarStyles = () => {\n    switch (variant) {\n      case \"compact\":\n        return \"flex items-center gap-3 mt-2\";\n      case \"card\":\n        return \"flex items-center gap-4 mt-3 pt-3 border-t border-gray-100\";\n      case \"bubble\":\n        return \"flex items-center gap-2 mt-2\";\n      case \"timeline\":\n        return \"flex items-center gap-4 mt-4 pt-3 border-t border-blue-100\";\n      case \"social\":\n        return \"flex items-center justify-start gap-4 mt-4 pt-3 border-t border-gray-100\";\n      case \"professional\":\n        return \"flex items-center gap-4 mt-3 pt-3 border-t border-gray-200\";\n      case \"clean\":\n        return \"flex items-center gap-3 mt-2\";\n      case \"github\":\n        return \"flex items-center gap-2 mt-2\";\n      case \"email\":\n        return \"flex items-center gap-3 mt-3 pt-2 border-t border-gray-100\";\n      case \"notion\":\n        return \"flex items-center gap-2 mt-2 opacity-0 group-hover:opacity-100 transition-opacity\";\n      case \"mobile\":\n        return \"flex items-center gap-2 mt-4\";\n      case \"thread\":\n        return \"flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity duration-150\";\n      case \"plain\":\n        return \"flex items-center gap-3 mt-2\";\n      default:\n        return \"flex items-center gap-3 mt-2\";\n    }\n  };\n\n  const getButtonStyles = (action?: string) => {\n    const baseStyles = getBaseButtonStyles();\n    const actionStyles = getActionSpecificStyles(action);\n    return `${baseStyles} ${actionStyles}`;\n  };\n\n  const getBaseButtonStyles = () => {\n    switch (variant) {\n      case \"compact\":\n        return \"h-6 px-2 text-xs\";\n      case \"card\":\n        return \"h-8 px-3 text-sm\";\n      case \"bubble\":\n        return \"h-7 px-2 text-xs\";\n      case \"timeline\":\n        return \"h-8 px-2 text-sm\";\n      case \"social\":\n        return \"h-8 px-3 text-sm\";\n      case \"professional\":\n        return \"h-8 px-4 text-sm\";\n      case \"clean\":\n        return \"h-7 px-2 text-sm\";\n      case \"github\":\n        return \"h-6 px-2 text-xs\";\n      case \"email\":\n        return \"h-7 px-3 text-sm\";\n      case \"notion\":\n        return \"h-6 px-2 text-xs\";\n      case \"mobile\":\n        return \"h-9 px-3 text-sm rounded-full flex-grow\";\n      case \"thread\":\n        return \"h-6 px-2 text-xs\";\n      case \"plain\":\n        return \"h-6 px-2 text-sm\";\n      default:\n        return \"h-6 px-2 text-xs\";\n    }\n  };\n\n  const getActionSpecificStyles = (action?: string) => {\n    switch (variant) {\n      case \"professional\":\n        switch (action) {\n          case \"approve\":\n            return \"text-slate-600 hover:text-blue-600 hover:bg-blue-50\";\n          case \"delete\":\n            return \"text-slate-600 hover:text-red-600 hover:bg-red-50\";\n          default:\n            return \"text-slate-600 hover:text-slate-800 hover:bg-slate-100\";\n        }\n      case \"thread\":\n        switch (action) {\n          case \"like\":\n            return \"text-gray-500 hover:text-blue-600 hover:bg-blue-50\";\n          case \"reply\":\n            return \"text-gray-500 hover:text-green-600 hover:bg-green-50\";\n          case \"delete\":\n            return \"text-gray-500 hover:text-red-600 hover:bg-red-50\";\n          default:\n            return \"text-gray-500 hover:text-blue-600 hover:bg-blue-50\";\n        }\n      case \"social\":\n        switch (action) {\n          case \"like\":\n            return \"text-gray-600 hover:text-pink-600 hover:bg-pink-50\";\n          case \"reply\":\n            return \"text-gray-600 hover:text-blue-600 hover:bg-blue-50\";\n          case \"share\":\n            return \"text-gray-600 hover:text-green-600 hover:bg-green-50\";\n          case \"delete\":\n            return \"text-gray-600 hover:text-red-600 hover:bg-red-50\";\n          default:\n            return \"text-gray-600 hover:text-gray-800\";\n        }\n      case \"notion\":\n        switch (action) {\n          case \"like\":\n            return \"text-gray-500 hover:text-orange-600 hover:bg-orange-50\";\n          case \"delete\":\n            return \"text-gray-500 hover:text-red-600 hover:bg-red-50\";\n          default:\n            return \"text-gray-500 hover:text-gray-700 hover:bg-gray-100\";\n        }\n      case \"compact\":\n        return \"text-gray-500 hover:text-gray-700\";\n      case \"card\":\n        return \"text-gray-600 hover:text-gray-800\";\n      case \"bubble\":\n        return \"text-blue-600 hover:text-blue-800\";\n      case \"timeline\":\n        return \"text-blue-600 hover:text-blue-800\";\n      case \"clean\":\n        return \"text-gray-500 hover:text-gray-700\";\n      case \"github\":\n        return \"text-gray-600 hover:text-gray-800\";\n      case \"email\":\n        return \"text-gray-600 hover:text-gray-800\";\n      case \"mobile\":\n        switch (action) {\n          case \"like\":\n            return \"text-gray-600 hover:text-pink-600 hover:bg-pink-50\";\n          case \"reply\":\n            return \"text-gray-600 hover:text-blue-600 hover:bg-blue-50\";\n          case \"edit\":\n            return \"text-gray-600 hover:text-gray-800 hover:bg-gray-100\";\n          case \"delete\":\n            return \"text-gray-600 hover:text-red-600 hover:bg-red-50\";\n          default:\n            return \"text-gray-600 hover:text-gray-800 hover:bg-gray-100\";\n        }\n      case \"plain\":\n        return \"text-gray-500 hover:text-gray-700\";\n      default:\n        return \"text-gray-500 hover:text-gray-700\";\n    }\n  };\n\n  const getIconSize = () => {\n    switch (variant) {\n      case \"mobile\":\n        return \"w-5 h-5\";\n      case \"social\":\n        return \"w-4 h-4\";\n      case \"professional\":\n        return \"w-4 h-4\";\n      case \"thread\":\n        return \"w-3 h-3\";\n      case \"notion\":\n        return \"w-3 h-3\";\n      default:\n        return \"w-3 h-3\";\n    }\n  };\n\n  const getIconMargin = (showText: boolean) => {\n    if (!showText) return \"mr-0\";\n\n    switch (variant) {\n      case \"professional\":\n      case \"social\":\n        return \"mr-2\";\n      case \"thread\":\n        return \"mr-1\";\n      default:\n        return \"mr-1\";\n    }\n  };\n\n  const showTextLabels = () => {\n    switch (variant) {\n      case \"compact\":\n      case \"card\":\n      case \"mobile\":\n      case \"social\":\n      case \"email\":\n      case \"professional\":\n      case \"github\":\n        return true;\n      case \"bubble\":\n      case \"timeline\":\n      case \"clean\":\n      case \"notion\":\n      case \"thread\":\n      case \"plain\":\n        return false;\n      default:\n        return true;\n    }\n  };\n\n  const iconSize = getIconSize();\n  const showText = showTextLabels();\n  const iconMargin = getIconMargin(showText);\n\n  // Hide actions when editing (except toggle edit button)\n  if (isEditing) {\n    return (\n      <div className={getActionBarStyles()}>\n        {isOwner && onToggleEdit && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onToggleEdit}\n            className={getButtonStyles()}\n          >\n            <X className={`${iconSize} ${iconMargin}`} />\n            Close\n          </Button>\n        )}\n      </div>\n    );\n  }\n\n  return (\n    <>\n      <div className={getActionBarStyles()}>\n        {onReact && variant === \"github\" && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={() => onReact(\"👍\")}\n            className={getButtonStyles(\"react\")}\n          >\n            <ThumbsUp className={`${iconSize} ${iconMargin}`} />\n            {showText ? \"👍 React\" : \"👍\"}\n          </Button>\n        )}\n\n        {onLike && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onLike}\n            className={getButtonStyles(\"like\")}\n          >\n            <Heart className={`${iconSize} ${iconMargin}`} />\n            {showText ? \"Like\" : \"\"}\n          </Button>\n        )}\n\n        {(onReply || onReplyCancel) && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={isReplyingTo ? onReplyCancel : onReply}\n            className={getButtonStyles(\"reply\")}\n          >\n            {isReplyingTo ? (\n              <MessageCircleXIcon className={`${iconSize} ${iconMargin}`} />\n            ) : (\n              <MessageCircle className={`${iconSize} ${iconMargin}`} />\n            )}\n            {showText ? (isReplyingTo ? \"Cancel\" : \"Reply\") : \"\"}\n          </Button>\n        )}\n\n        {comment.sourceReference && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={() => setShowReferences(!showReferences)}\n            className={`${getButtonStyles(\"reference\")} ${\n              showReferences ? \"text-purple-600 bg-purple-50\" : \"\"\n            }`}\n          >\n            <BookText className={`${iconSize} ${iconMargin}`} />\n            {showText ? \"References\" : \"\"}\n          </Button>\n        )}\n\n        {onShare && variant === \"social\" && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onShare}\n            className={getButtonStyles(\"share\")}\n          >\n            <Share2Icon className={`${iconSize} ${iconMargin}`} />\n            {showText ? \"Share\" : \"\"}\n          </Button>\n        )}\n\n        {onForward && variant === \"email\" && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onForward}\n            className={getButtonStyles()}\n          >\n            <ForwardIcon className={`${iconSize} ${iconMargin}`} />\n            {showText ? \"Forward\" : \"\"}\n          </Button>\n        )}\n\n        {onApprove && variant === \"professional\" && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onApprove}\n            className={getButtonStyles(\"approve\")}\n          >\n            <CheckCircle2Icon className={`${iconSize} ${iconMargin}`} />\n            {showText ? \"Approve\" : \"\"}\n          </Button>\n        )}\n\n        {isOwner && (\n          <>\n            {onToggleEdit && (\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                onClick={onToggleEdit}\n                className={getButtonStyles(\"edit\")}\n              >\n                <Edit className={`${iconSize} ${iconMargin}`} />\n                {showText ? \"Edit\" : \"\"}\n              </Button>\n            )}\n\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={handleDeleteClick}\n              className={getButtonStyles(\"delete\")}\n            >\n              <Trash2 className={`${iconSize} ${iconMargin}`} />\n              {showText ? \"Delete\" : \"\"}\n            </Button>\n          </>\n        )}\n      </div>\n\n      {/* Source Reference Display */}\n      {comment.sourceReference && showReferences && (\n        <div\n          className={\n            variant === \"github\"\n              ? \"mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg\"\n              : variant === \"professional\"\n              ? \"mt-4 p-3 bg-blue-50 border border-blue-200 rounded-lg\"\n              : variant === \"thread\"\n              ? \"mb-2 p-2 bg-blue-50 border border-blue-200 rounded-md\"\n              : variant === \"social\"\n              ? \"mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg\"\n              : variant === \"notion\"\n              ? \"mt-3 p-3 bg-orange-50 border border-orange-200 rounded-md\"\n              : \"mt-2 p-2 bg-blue-50 border border-blue-200 rounded text-xs\"\n          }\n        >\n          <div className=\"flex items-start gap-2\">\n            <div\n              className={\n                variant === \"github\"\n                  ? \"w-2 h-2 bg-blue-500 rounded-full mt-2 flex-shrink-0\"\n                  : variant === \"thread\"\n                  ? \"w-1.5 h-1.5 bg-blue-500 rounded-full\"\n                  : variant === \"social\"\n                  ? \"w-2 h-2 bg-blue-500 rounded-full\"\n                  : variant === \"notion\"\n                  ? \"w-1.5 h-1.5 bg-orange-500 rounded-full mt-2 flex-shrink-0\"\n                  : \"w-1 h-1 rounded-full bg-blue-400 mt-1.5 flex-shrink-0\"\n              }\n            ></div>\n            <div className=\"flex-1\">\n              {variant === \"notion\" ? (\n                <>\n                  <div className=\"text-xs font-medium text-orange-700 mb-1\">\n                    Referenced:\n                  </div>\n                  <div className=\"text-sm font-medium text-orange-900\">\n                    {comment.sourceReference.label}\n                  </div>\n                </>\n              ) : (\n                <>\n                  <span className=\"text-blue-700 font-medium\">\n                    Referenced:{\" \"}\n                  </span>\n                  <span className=\"text-blue-800\">\n                    {comment.sourceReference.label}\n                  </span>\n                </>\n              )}\n              {comment.sourceReference.description && (\n                <div className=\"text-blue-600 mt-1\">\n                  {comment.sourceReference.description}\n                </div>\n              )}\n              {comment.sourceReference.url && (\n                <a\n                  href={comment.sourceReference.url}\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                  className=\"text-blue-600 hover:text-blue-800 underline mt-1 inline-block\"\n                >\n                  View Source �\n                </a>\n              )}\n            </div>\n          </div>\n        </div>\n      )}\n\n      <DeleteConfirmationDialog\n        isOpen={showDeleteDialog}\n        onClose={() => setShowDeleteDialog(false)}\n        onConfirm={handleConfirmDelete}\n        commentAuthor={comment.author.name}\n        hasReplies={replies.length > 0}\n        replyCount={replies.length}\n      />\n    </>\n  );\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/comments/comment-source-reference.tsx",
      "content": "\"use client\"\n\nimport Link from \"next/link\";\nimport { ExternalLink } from \"lucide-react\";\nimport type { Comment } from \"@/lib/comments/types/comments\";\nimport { type CommentVariant } from \"@/lib/comments/types/comments\";\n\ninterface CommentSourceReferenceProps {\n  sourceReference: Comment[\"sourceReference\"]\n  variant: CommentVariant\n  className?: string\n}\n\nexport function CommentSourceReference({\n  sourceReference,\n  variant,\n  className = \"\",\n}: CommentSourceReferenceProps) {\n  if (!sourceReference) return null\n\n  const getVariantStyles = () => {\n    switch (variant) {\n      case \"clean\":\n        return {\n          container: \"mt-4 p-3 bg-gray-50 border border-gray-200 rounded-lg\",\n          dot: \"w-1.5 h-1.5 bg-gray-400 rounded-full mt-2 flex-shrink-0\",\n          label: \"text-xs font-medium text-gray-600 mb-1\",\n          title: \"text-sm font-medium text-gray-900\",\n          description: \"text-xs text-gray-600 mt-1\",\n          link: \"inline-flex items-center gap-1 text-xs text-gray-600 hover:text-gray-800 mt-2 font-medium\",\n        }\n      case \"notion\":\n        return {\n          container: \"mt-3 p-3 bg-orange-50 border border-orange-200 rounded-md\",\n          dot: \"w-1.5 h-1.5 bg-orange-500 rounded-full mt-2 flex-shrink-0\",\n          label: \"text-xs font-medium text-orange-700 mb-1\",\n          title: \"text-sm font-medium text-orange-900\",\n          description: \"text-xs text-orange-600 mt-1\",\n          link: \"inline-flex items-center gap-1 text-xs text-orange-600 hover:text-orange-800 mt-2 font-medium\",\n        }\n      case \"github\":\n        return {\n          container: \"mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg\",\n          dot: \"w-2 h-2 bg-blue-500 rounded-full mt-2 flex-shrink-0\",\n          label: \"text-sm font-medium text-blue-700 mb-1\",\n          title: \"text-sm font-medium text-blue-800\",\n          description: \"text-sm text-blue-600 mt-1\",\n          link: \"inline-flex items-center gap-1 text-sm text-blue-600 hover:text-blue-800 mt-2\",\n        }\n      case \"professional\":\n        return {\n          container: \"mt-4 p-3 bg-blue-50 border border-blue-200 rounded-lg\",\n          dot: \"w-2 h-2 bg-blue-500 rounded-full mt-2 flex-shrink-0\",\n          label: \"text-sm font-medium text-blue-700 mb-1\",\n          title: \"text-sm font-medium text-blue-800\",\n          description: \"text-sm text-blue-600 mt-1\",\n          link: \"inline-flex items-center gap-1 text-sm text-blue-600 hover:text-blue-800 mt-2\",\n        }\n      case \"thread\":\n        return {\n          container: \"mb-2 p-2 bg-blue-50 border border-blue-200 rounded-md\",\n          dot: \"w-1.5 h-1.5 bg-blue-500 rounded-full\",\n          label: \"text-xs font-medium text-blue-700\",\n          title: \"text-xs font-medium text-blue-800\",\n          description: \"text-xs text-blue-600 mt-1\",\n          link: \"inline-flex items-center gap-1 text-xs text-blue-600 hover:text-blue-800 mt-1\",\n        }\n      case \"social\":\n        return {\n          container: \"mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg\",\n          dot: \"w-2 h-2 bg-blue-500 rounded-full\",\n          label: \"text-sm font-medium text-blue-700 mb-1\",\n          title: \"text-sm font-medium text-blue-800\",\n          description: \"text-sm text-blue-600 mt-1\",\n          link: \"inline-flex items-center gap-1 text-sm text-blue-600 hover:text-blue-800 mt-2\",\n        }\n      case \"card\":\n        return {\n          container: \"mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg\",\n          dot: \"w-2 h-2 bg-blue-500 rounded-full mt-2 flex-shrink-0\",\n          label: \"text-sm font-medium text-blue-800\",\n          title: \"text-sm font-medium text-blue-800\",\n          description: \"text-sm text-blue-700 mt-1\",\n          link: \"inline-flex items-center gap-1 text-sm text-blue-600 hover:text-blue-800 mt-2\",\n        }\n      case \"email\":\n        return {\n          container: \"mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg\",\n          dot: \"w-2 h-2 bg-blue-500 rounded-full mt-2 flex-shrink-0\",\n          label: \"text-sm font-medium text-blue-800\",\n          title: \"text-sm font-medium text-blue-800\",\n          description: \"text-sm text-blue-700 mt-1\",\n          link: \"inline-flex items-center gap-1 text-sm text-blue-600 hover:text-blue-800 mt-2\",\n        }\n      case \"bubble\":\n        return {\n          container: \"mt-2 p-2 bg-blue-50 border border-blue-200 rounded-lg text-xs\",\n          dot: \"w-1.5 h-1.5 bg-blue-500 rounded-full\",\n          label: \"font-medium text-blue-700\",\n          title: \"text-blue-700\",\n          description: \"text-blue-600 mt-1\",\n          link: \"ml-1 text-blue-600 hover:text-blue-800 flex items-center gap-1\",\n        }\n      case \"timeline\":\n        return {\n          container: \"mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg\",\n          dot: \"w-2 h-2 bg-blue-500 rounded-full mt-1 flex-shrink-0\",\n          label: \"text-sm font-medium text-blue-700 mb-1\",\n          title: \"text-sm font-medium text-blue-800\",\n          description: \"text-sm text-blue-600 mt-1\",\n          link: \"inline-flex items-center gap-1 text-sm text-blue-600 hover:text-blue-800 mt-2\",\n        }\n      case \"mobile\":\n        return {\n          container: \"mt-4 p-4 bg-blue-50 border border-blue-200 rounded-lg\",\n          dot: \"w-2 h-2 bg-blue-500 rounded-full mt-1 flex-shrink-0\",\n          label: \"text-sm font-medium text-blue-700 mb-1\",\n          title: \"text-base font-medium text-blue-800\",\n          description: \"text-sm text-blue-600 mt-1\",\n          link: \"inline-flex items-center gap-1 text-sm text-blue-600 hover:text-blue-800 mt-3\",\n        }\n      case \"compact\":\n        return {\n          container: \"mt-2 p-2 bg-blue-50 border border-blue-200 rounded text-xs\",\n          dot: \"w-1 h-1 rounded-full bg-blue-400 mt-1.5 flex-shrink-0\",\n          label: \"font-medium text-blue-700\",\n          title: \"text-blue-800\",\n          description: \"text-blue-600 mt-1\",\n          link: \"inline-flex items-center gap-1 text-blue-600 hover:text-blue-800 mt-1\",\n        }\n      case \"plain\":\n        return {\n          container: \"mt-2 p-2 bg-gray-50 border border-gray-200 rounded\",\n          dot: \"w-1.5 h-1.5 bg-gray-400 rounded-full mt-1.5 flex-shrink-0\",\n          label: \"text-xs font-medium text-gray-600 mb-1\",\n          title: \"text-sm font-medium text-gray-900\",\n          description: \"text-xs text-gray-600 mt-1\",\n          link: \"inline-flex items-center gap-1 text-xs text-gray-600 hover:text-gray-800 mt-2\",\n        }\n      default:\n        return {\n          container: \"mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg\",\n          dot: \"w-2 h-2 bg-blue-500 rounded-full mt-2 flex-shrink-0\",\n          label: \"text-sm font-medium text-blue-700 mb-1\",\n          title: \"text-sm font-medium text-blue-800\",\n          description: \"text-sm text-blue-600 mt-1\",\n          link: \"inline-flex items-center gap-1 text-sm text-blue-600 hover:text-blue-800 mt-2\",\n        }\n    }\n  }\n\n  const styles = getVariantStyles()\n\n  return (\n    <div className={`${styles.container} ${className}`}>\n      <div className=\"flex items-start gap-2\">\n        <div className={styles.dot}></div>\n        <div className=\"flex-1\">\n          {variant === \"notion\" ? (\n            <>\n              <div className={styles.label}>Referenced:</div>\n              <div className={styles.title}>{sourceReference.label}</div>\n            </>\n          ) : variant === \"bubble\" ? (\n            <div className=\"flex items-center gap-1 text-blue-700\">\n              <span className={styles.label}>Referenced:</span>\n              <span className={styles.title}>{sourceReference.label}</span>\n              {sourceReference.description && (\n                <span className={styles.description}>- {sourceReference.description}</span>\n              )}\n              {sourceReference.url && (\n                <Link\n                  href={sourceReference.url}\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                  className={styles.link}\n                >\n                  View Source\n                  <ExternalLink className=\"w-3 h-3\" />\n                </Link>\n              )}\n            </div>\n          ) : variant === \"card\" ? (\n            <div className=\"text-sm text-blue-800\">\n              <span className=\"font-medium\">Referenced:</span> {sourceReference.label}\n            </div>\n          ) : (\n            <>\n              <div className={styles.label}>Referenced:</div>\n              <div className={styles.title}>{sourceReference.label}</div>\n            </>\n          )}\n          \n          {variant !== \"bubble\" && variant !== \"card\" && (\n            <>\n              {sourceReference.description && (\n                <div className={styles.description}>{sourceReference.description}</div>\n              )}\n              {sourceReference.url && (\n                <Link\n                  href={sourceReference.url}\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                  className={styles.link}\n                >\n                  View Source <ExternalLink className=\"w-3 h-3\" />\n                </Link>\n              )}\n            </>\n          )}\n          \n          {variant === \"card\" && (\n            <>\n              {sourceReference.description && (\n                <div className={styles.description}>{sourceReference.description}</div>\n              )}\n              {sourceReference.url && (\n                <Link\n                  href={sourceReference.url}\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                  className={styles.link}\n                >\n                  View Source\n                  <ExternalLink className=\"w-3 h-3\" />\n                </Link>\n              )}\n            </>\n          )}\n        </div>\n      </div>\n    </div>\n  )\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/comments/comment-variations.tsx",
      "content": "\"use client\"\nimport { useState } from \"react\"\nimport type { Comment, CommentVariant, User as UserType } from \"@/lib/comments/types/comments\"\nimport { CardVariant } from \"./variants/card-variant\"\nimport { GitHubVariant } from \"./variants/github-variant\"\nimport { EmailVariant } from \"./variants/email-variant\"\nimport { BubbleVariant } from \"./variants/bubble-variant\"\nimport { TimelineVariant } from \"./variants/timeline-variant\"\nimport { SocialVariant } from \"./variants/social-variant\"\nimport { ThreadVariant } from \"./variants/thread-variant\"\nimport { ProfessionalVariant } from \"./variants/professional-variant\"\nimport { MobileVariant } from \"./variants/mobile-variant\"\nimport { NotionVariant } from \"./variants/notion-variant\"\nimport { CleanVariant } from \"./variants/clean-variant\"\nimport { CompactVariant } from \"./variants/compact-variant\"\nimport { PlainVariant } from \"./variants/plain-variant\"\n\nexport interface CommentVariationProps {\n  comment: Comment\n  currentUser: UserType\n  variant: CommentVariant\n  showInlineEdit?: boolean\n  replies?: Comment[]\n  isReplyingTo?: boolean\n  onEdit?: (commentId: string, content: string, editorState: string) => void\n  onDelete?: (commentId: string) => void\n  onReply?: (commentId: string) => void\n  onReplyCancel?: () => void\n  // Custom action callbacks\n  onLike?: (commentId: string) => void\n  onShare?: (commentId: string) => void\n  onForward?: (commentId: string) => void\n  onApprove?: (commentId: string) => void\n  onReact?: (commentId: string, reaction: string) => void\n}\n\nexport function CommentVariation({\n  comment,\n  currentUser,\n  variant,\n  showInlineEdit,\n  replies = [],\n  isReplyingTo = false,\n  onEdit,\n  onDelete,\n  onReply,\n  onReplyCancel,\n  onLike,\n  onShare,\n  onForward,\n  onApprove,\n  onReact,\n}: CommentVariationProps) {\n  const [isEditing, setIsEditing] = useState(showInlineEdit || false)\n\n  const handleDelete = () => onDelete?.(comment.id)\n  const handleReply = () => onReply?.(comment.id)\n  const handleLike = () => onLike?.(comment.id)\n  const handleShare = () => onShare?.(comment.id)\n  const handleForward = () => onForward?.(comment.id)\n  const handleApprove = () => onApprove?.(comment.id)\n  const handleReact = (reaction: string) => onReact?.(comment.id, reaction)\n\n  const isReply = !!comment.parentId\n\n  if (variant === \"card\") {\n    return (\n      <CardVariant\n        comment={comment}\n        currentUser={currentUser}\n        isReply={isReply}\n        isEditing={isEditing}\n        setIsEditing={setIsEditing}\n        isReplyingTo={isReplyingTo}\n        onEdit={onEdit}\n        onDelete={handleDelete}\n        onReply={handleReply}\n        onReplyCancel={onReplyCancel}\n        onLike={handleLike}\n        replies={replies}\n      />\n    )\n  }\n\n  if (variant === \"github\") {\n    return (\n      <GitHubVariant\n        comment={comment}\n        currentUser={currentUser}\n        isReply={isReply}\n        isEditing={isEditing}\n        setIsEditing={setIsEditing}\n        isReplyingTo={isReplyingTo}\n        onEdit={onEdit}\n        onDelete={handleDelete}\n        onReply={handleReply}\n        onReplyCancel={onReplyCancel}\n        onReact={handleReact}\n      />\n    )\n  }\n\n  if (variant === \"email\") {\n    return (\n      <EmailVariant\n        comment={comment}\n        currentUser={currentUser}\n        isReply={isReply}\n        isEditing={isEditing}\n        setIsEditing={setIsEditing}\n        isReplyingTo={isReplyingTo}\n        onEdit={onEdit}\n        onDelete={handleDelete}\n        onReply={handleReply}\n        onReplyCancel={onReplyCancel}\n        onForward={handleForward}\n      />\n    )\n  }\n\n  if (variant === \"bubble\") {\n    return (\n      <BubbleVariant\n        comment={comment}\n        currentUser={currentUser}\n        isReply={isReply}\n        isEditing={isEditing}\n        setIsEditing={setIsEditing}\n        isReplyingTo={isReplyingTo}\n        onEdit={onEdit}\n        onDelete={handleDelete}\n        onReply={handleReply}\n        onReplyCancel={onReplyCancel}\n        onLike={handleLike}\n      />\n    )\n  }\n\n  if (variant === \"timeline\") {\n    return (\n      <TimelineVariant\n        comment={comment}\n        currentUser={currentUser}\n        isReply={isReply}\n        isEditing={isEditing}\n        setIsEditing={setIsEditing}\n        isReplyingTo={isReplyingTo}\n        onEdit={onEdit}\n        onDelete={handleDelete}\n        onReply={handleReply}\n        onReplyCancel={onReplyCancel}\n        onLike={handleLike}\n      />\n    )\n  }\n\n  if (variant === \"social\") {\n    return (\n      <SocialVariant\n        comment={comment}\n        currentUser={currentUser}\n        isReply={isReply}\n        isEditing={isEditing}\n        setIsEditing={setIsEditing}\n        isReplyingTo={isReplyingTo}\n        onEdit={onEdit}\n        onDelete={handleDelete}\n        onReply={handleReply}\n        onReplyCancel={onReplyCancel}\n        onLike={handleLike}\n        onShare={handleShare}\n      />\n    )\n  }\n\n  if (variant === \"thread\") {\n    return (\n      <ThreadVariant\n        comment={comment}\n        currentUser={currentUser}\n        isReply={isReply}\n        isEditing={isEditing}\n        setIsEditing={setIsEditing}\n        isReplyingTo={isReplyingTo}\n        onEdit={onEdit}\n        onDelete={handleDelete}\n        onReply={handleReply}\n        onReplyCancel={onReplyCancel}\n        onLike={handleLike}\n      />\n    )\n  }\n\n  if (variant === \"professional\") {\n    return (\n      <ProfessionalVariant\n        comment={comment}\n        currentUser={currentUser}\n        isReply={isReply}\n        isEditing={isEditing}\n        setIsEditing={setIsEditing}\n        isReplyingTo={isReplyingTo}\n        onEdit={onEdit}\n        onDelete={handleDelete}\n        onReply={handleReply}\n        onReplyCancel={onReplyCancel}\n        onApprove={handleApprove}\n      />\n    )\n  }\n\n  if (variant === \"mobile\") {\n    return (\n      <MobileVariant\n        comment={comment}\n        currentUser={currentUser}\n        isReply={isReply}\n        isEditing={isEditing}\n        setIsEditing={setIsEditing}\n        isReplyingTo={isReplyingTo}\n        onEdit={onEdit}\n        onDelete={handleDelete}\n        onReply={handleReply}\n        onReplyCancel={onReplyCancel}\n        onLike={handleLike}\n      />\n    )\n  }\n\n  if (variant === \"notion\") {\n    return (\n      <NotionVariant\n        comment={comment}\n        currentUser={currentUser}\n        isReply={isReply}\n        isEditing={isEditing}\n        setIsEditing={setIsEditing}\n        isReplyingTo={isReplyingTo}\n        onEdit={onEdit}\n        onDelete={handleDelete}\n        onReply={handleReply}\n        onReplyCancel={onReplyCancel}\n        onLike={handleLike}\n      />\n    )\n  }\n\n  if (variant === \"clean\") {\n    return (\n      <CleanVariant\n        comment={comment}\n        currentUser={currentUser}\n        isReply={isReply}\n        isEditing={isEditing}\n        setIsEditing={setIsEditing}\n        isReplyingTo={isReplyingTo}\n        onEdit={onEdit}\n        onDelete={handleDelete}\n        onReply={handleReply}\n        onReplyCancel={onReplyCancel}\n        onLike={handleLike}\n      />\n    )\n  }\n\n  if (variant === \"compact\") {\n    return (\n      <CompactVariant\n        comment={comment}\n        currentUser={currentUser}\n        isReply={isReply}\n        isEditing={isEditing}\n        setIsEditing={setIsEditing}\n        isReplyingTo={isReplyingTo}\n        onEdit={onEdit}\n        onDelete={handleDelete}\n        onReply={handleReply}\n        onReplyCancel={onReplyCancel}\n        onLike={handleLike}\n        replies={replies}\n      />\n    )\n  }\n\n  if (variant === \"plain\") {\n    return (\n      <PlainVariant\n        comment={comment}\n        currentUser={currentUser}\n        isReply={isReply}\n        isEditing={isEditing}\n        setIsEditing={setIsEditing}\n        isReplyingTo={isReplyingTo}\n        onEdit={onEdit}\n        onDelete={handleDelete}\n        onReply={handleReply}\n        onReplyCancel={onReplyCancel}\n        onLike={handleLike}\n      />\n    )\n  }\n\n  return null\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/comments/delete-confirmation-dialog.tsx",
      "content": "\"use client\"\n\nimport { useState } from \"react\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\"\nimport { AlertTriangle, Trash2 } from \"lucide-react\"\n\ninterface DeleteConfirmationDialogProps {\n  isOpen: boolean\n  onClose: () => void\n  onConfirm: () => void\n  commentAuthor: string\n  hasReplies: boolean\n  replyCount?: number\n}\n\nexport function DeleteConfirmationDialog({\n  isOpen,\n  onClose,\n  onConfirm,\n  commentAuthor,\n  hasReplies,\n  replyCount = 0,\n}: DeleteConfirmationDialogProps) {\n  const [isDeleting, setIsDeleting] = useState(false)\n\n  const handleConfirm = async () => {\n    if (hasReplies) return // Shouldn't happen, but safety check\n\n    setIsDeleting(true)\n    try {\n      await onConfirm()\n      onClose()\n    } finally {\n      setIsDeleting(false)\n    }\n  }\n\n  return (\n    <Dialog open={isOpen} onOpenChange={onClose}>\n      <DialogContent className=\"sm:max-w-md\">\n        <DialogHeader>\n          <DialogTitle className=\"flex items-center gap-2\">\n            {hasReplies ? (\n              <>\n                <AlertTriangle className=\"h-5 w-5 text-amber-500\" />\n                Cannot Delete Comment\n              </>\n            ) : (\n              <>\n                <Trash2 className=\"h-5 w-5 text-red-500\" />\n                Delete Comment\n              </>\n            )}\n          </DialogTitle>\n          <DialogDescription asChild>\n            {hasReplies ? (\n              <>\n                <p>\n                  This comment by <strong>{commentAuthor}</strong> cannot be deleted because it has{\" \"}\n                  <strong>\n                    {replyCount} {replyCount === 1 ? \"reply\" : \"replies\"}\n                  </strong>\n                  .\n                </p>\n                <p className=\"text-sm text-gray-600 mt-2\">\n                  To delete this comment, you must first remove all replies to it.\n                </p>\n              </>\n            ) : (\n              <p>\n                Are you sure you want to delete this comment by <strong>{commentAuthor}</strong>? This action cannot be\n                undone.\n              </p>\n            )}\n          </DialogDescription>\n        </DialogHeader>\n        <DialogFooter>\n          {hasReplies ? (\n            <Button onClick={onClose} className=\"w-full\">\n              Got it\n            </Button>\n          ) : (\n            <div className=\"flex gap-2 w-full\">\n              <Button variant=\"outline\" onClick={onClose} className=\"flex-1 bg-transparent\">\n                Cancel\n              </Button>\n              <Button variant=\"destructive\" onClick={handleConfirm} disabled={isDeleting} className=\"flex-1\">\n                {isDeleting ? \"Deleting...\" : \"Delete\"}\n              </Button>\n            </div>\n          )}\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  )\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/comments/variants/bubble-variant.tsx",
      "content": "\"use client\"\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/components/ui/avatar\"\nimport { formatTimeAgo } from '@/lib/comments/utils/formatTimeAgo'\nimport { LexicalCommentComposer } from \"@/lib/comments/components/lexical/lexical-comment-composer\"\nimport { LexicalReadOnlyRenderer } from \"@/lib/comments/components/lexical/lexical-read-only-renderer\"\nimport { CommentActionBar } from \"@/lib/comments/components/comments/comment-action-bar\"\nimport { CommentSourceReference } from \"../comment-source-reference\"\nimport type { Comment, User as UserType } from \"@/lib/comments/types/comments\"\n\ninterface BubbleVariantProps {\n  comment: Comment\n  currentUser: UserType\n  isReply: boolean\n  isEditing: boolean\n  setIsEditing: (editing: boolean) => void\n  isReplyingTo?: boolean\n  onEdit?: (commentId: string, content: string, editorState: string) => void\n  onDelete?: () => void\n  onReply?: () => void\n  onReplyCancel?: () => void\n  onLike?: () => void\n  replies?: Comment[]\n}\n\nexport function BubbleVariant({\n  comment,\n  currentUser,\n  isReply,\n  isEditing,\n  setIsEditing,\n  isReplyingTo = false,\n  onEdit,\n  onDelete,\n  onReply,\n  onReplyCancel,\n  onLike,\n  replies = [],\n}: BubbleVariantProps) {\n\n  const styles = {\n    container: \"max-w-md\",\n    replyContainer: \"ml-12 mt-2\",\n    content: \"bg-blue-600 text-white rounded-2xl rounded-bl-sm px-4 py-3 inline-block\",\n    replyContent: \"bg-gray-100 text-gray-800 rounded-2xl rounded-br-sm px-4 py-3 inline-block\",\n    avatar: \"h-8 w-8 flex-shrink-0\",\n    avatarFallback: \"bg-blue-100 text-blue-700 text-sm font-medium\",\n    name: \"font-medium text-white mb-1\",\n    replyName: \"font-medium text-gray-900 mb-1\",\n    timestamp: \"text-xs text-blue-200 mt-1\",\n    replyTimestamp: \"text-xs text-gray-500 mt-1\",\n    actions: \"flex items-center gap-2 mt-2 justify-end\",\n    actionButton: \"text-blue-500 hover:text-blue-700 text-xs\",\n  }\n\n  const getInitials = (name: string) => {\n    return name\n      .split(\" \")\n      .map((n) => n[0])\n      .join(\"\")\n      .toUpperCase()\n  }\n\n  const handleEditSubmit = async (content: string, editorState: string) => {\n    if (onEdit) {\n      await onEdit(comment.id, content, editorState)\n      setIsEditing(false)\n    }\n  }\n\n  const isCurrentUser = comment.author.id === currentUser.id\n\n  return (\n    <>\n      <div className={`flex ${isReply ? \"justify-start\" : \"justify-end\"} mb-4`}>\n        <div className={`${styles.container} ${isReply ? styles.replyContainer : \"\"}`}>\n          <div className=\"flex gap-2 items-start\">\n            {isReply && (\n              <Avatar className={styles.avatar}>\n                <AvatarImage src={comment.author.avatar || \"/placeholder.svg\"} alt={comment.author.name} />\n                <AvatarFallback className={styles.avatarFallback}>{getInitials(comment.author.name)}</AvatarFallback>\n              </Avatar>\n            )}\n            <div>\n              <div className={isReply ? styles.replyContent : styles.content}>\n                <div className={isReply ? styles.replyName : styles.name}>{comment.author.name}</div>\n                {isEditing ? (\n                  <LexicalCommentComposer\n                    variant=\"bubble\"\n                    placeholder=\"Edit your comment...\"\n                    onSubmit={handleEditSubmit}\n                    className=\"border border-gray-300 rounded-md\"\n                    initialContent={comment.content}\n                    initialEditorState={comment.editorState}\n                  />\n                ) : (\n                  <>\n                    <LexicalReadOnlyRenderer\n                      editorState={comment.editorState}\n                      content={comment.content}\n                      className={`text-sm leading-relaxed ${isReply ? 'text-gray-800' : 'text-white'}`}\n                    />\n                    <div className={isReply ? styles.replyTimestamp : styles.timestamp}>\n                      {formatTimeAgo(comment.createdAt)}\n                    </div>\n                  </>\n                )}\n              </div>\n\n              <CommentActionBar\n                comment={comment}\n                currentUser={currentUser}\n                variant=\"bubble\"\n                isReply={isReply}\n                isEditing={isEditing}\n                isOwner={isCurrentUser}\n                isReplyingTo={isReplyingTo}\n                onEdit={onEdit}\n                onDelete={onDelete}\n                onReply={onReply}\n                onReplyCancel={onReplyCancel}\n                onLike={onLike}\n                onToggleEdit={() => setIsEditing(!isEditing)}\n                replies={replies}\n              />\n\n              <CommentSourceReference\n                sourceReference={comment.sourceReference}\n                variant=\"bubble\"\n              />\n            </div>\n            {!isReply && (\n              <Avatar className={styles.avatar}>\n                <AvatarImage src={comment.author.avatar || \"/placeholder.svg\"} alt={comment.author.name} />\n                <AvatarFallback className={styles.avatarFallback}>{getInitials(comment.author.name)}</AvatarFallback>\n              </Avatar>\n            )}\n          </div>\n        </div>\n      </div>\n    </>\n  )\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/comments/variants/card-variant.tsx",
      "content": "\"use client\";\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/components/ui/avatar\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Card, CardContent } from \"@/components/ui/card\";\nimport type { Comment, User as UserType } from \"@/lib/comments/types/comments\";\nimport { formatTimeAgo } from '@/lib/comments/utils/formatTimeAgo';\nimport { LexicalCommentComposer } from \"@/lib/comments/components/lexical/lexical-comment-composer\";\nimport { LexicalReadOnlyRenderer } from \"@/lib/comments/components/lexical/lexical-read-only-renderer\";\nimport { CommentActionBar } from \"@/lib/comments/components/comments/comment-action-bar\";\nimport { CommentSourceReference } from \"../comment-source-reference\";\n\ninterface CardVariantProps {\n  comment: Comment;\n  currentUser: UserType;\n  isReply: boolean;\n  isEditing: boolean;\n  setIsEditing: (editing: boolean) => void;\n  isReplyingTo?: boolean;\n  onEdit?: (commentId: string, content: string, editorState: string) => void;\n  onDelete?: () => void;\n  onReply?: () => void;\n  onReplyCancel?: () => void;\n  onLike?: () => void;\n  replies?: Comment[];\n}\n\nexport function CardVariant({\n  comment,\n  currentUser,\n  isReply,\n  isEditing,\n  setIsEditing,\n  isReplyingTo = false,\n  onEdit,\n  onDelete,\n  onReply,\n  onReplyCancel,\n  onLike,\n  replies = [],\n}: CardVariantProps) {\n  const getInitials = (name: string) => {\n    return name\n      .split(\" \")\n      .map((n) => n[0])\n      .join(\"\")\n      .toUpperCase();\n  };\n\n  const handleEditSubmit = async (content: string, editorState: string) => {\n    if (onEdit) {\n      await onEdit(comment.id, content, editorState);\n      setIsEditing(false);\n    }\n  };\n\n  const isCurrentUser = comment.author.id === currentUser.id;\n\n  return (\n    <Card\n      className={`shadow-sm py-4 hover:shadow-md transition-shadow duration-200 ${\n        isReply ? \"ml-8 border-l-4 border-l-green-400 bg-green-50/50\" : \"\"\n      }`}\n    >\n      <CardContent className=\"p-4\">\n        <div className=\"flex gap-3\">\n          <Avatar className=\"h-10 w-10 flex-shrink-0\">\n            <AvatarImage\n              src={comment.author.avatar || \"/placeholder.svg\"}\n              alt={comment.author.name}\n            />\n            <AvatarFallback className=\"bg-green-100 text-green-700 text-sm font-medium\">\n              {getInitials(comment.author.name)}\n            </AvatarFallback>\n          </Avatar>\n          <div className=\"flex-1 min-w-0\">\n            <div className=\"flex items-center gap-2 mb-2\">\n              {isReply && (\n                <span className=\"text-sm text-green-600 font-medium\">↳</span>\n              )}\n              <span className=\"font-semibold text-gray-900\">\n                {comment.author.name}\n              </span>\n              <Badge\n                variant=\"outline\"\n                className=\"text-xs px-2 py-0 bg-white border-gray-300 rounded-full\"\n              >\n                {comment.author.role}\n              </Badge>\n              <span className=\"text-sm text-gray-500\">\n                {formatTimeAgo(comment.createdAt)}\n              </span>\n              {isEditing && (\n                <Badge\n                  variant=\"secondary\"\n                  className=\"text-xs\"\n                >\n                  Editing\n                </Badge>\n              )}\n            </div>\n\n            {isEditing ? (\n              <LexicalCommentComposer\n                variant=\"card\"\n                placeholder=\"Edit your comment...\"\n                onSubmit={handleEditSubmit}\n                className=\"border border-gray-200 rounded-lg\"\n                initialContent={comment.content}\n                initialEditorState={comment.editorState}\n              />\n            ) : (\n              <div className=\"mb-3\">\n                <LexicalReadOnlyRenderer\n                  editorState={comment.editorState}\n                  content={comment.content}\n                  className=\"text-sm text-gray-800 leading-relaxed\"\n                />\n              </div>\n            )}\n\n            <CommentActionBar\n              comment={comment}\n              currentUser={currentUser}\n              variant=\"card\"\n              isReply={isReply}\n              isEditing={isEditing}\n              isOwner={isCurrentUser}\n              isReplyingTo={isReplyingTo}\n              onEdit={onEdit}\n              onDelete={onDelete}\n              onReply={onReply}\n              onReplyCancel={onReplyCancel}\n              onLike={onLike}\n              onToggleEdit={() => setIsEditing(!isEditing)}\n              replies={replies}\n            />\n\n            <CommentSourceReference\n              sourceReference={comment.sourceReference}\n              variant=\"card\"\n            />\n          </div>\n        </div>\n      </CardContent>\n    </Card>\n  );\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/comments/variants/clean-variant.tsx",
      "content": "\"use client\";\nimport { Badge } from \"@/components/ui/badge\";\nimport type { Comment, User as UserType } from \"@/lib/comments/types/comments\";\nimport { formatTimeAgo } from '@/lib/comments/utils/formatTimeAgo';\nimport { LexicalCommentComposer } from \"@/lib/comments/components/lexical/lexical-comment-composer\";\nimport { LexicalReadOnlyRenderer } from \"@/lib/comments/components/lexical/lexical-read-only-renderer\";\nimport { CommentActionBar } from \"../comment-action-bar\";\nimport { CommentSourceReference } from \"../comment-source-reference\";\n\ninterface CleanVariantProps {\n  comment: Comment;\n  currentUser: UserType;\n  isReply: boolean;\n  isEditing: boolean;\n  setIsEditing: (editing: boolean) => void;\n  onEdit?: (commentId: string, content: string, editorState: string) => void;\n  onDelete?: () => void;\n  onReply?: () => void;\n  onLike?: () => void;\n  isReplyingTo?: boolean;\n  onReplyCancel?: () => void;\n  replies?: Comment[];\n}\n\nexport function CleanVariant({\n  comment,\n  currentUser,\n  isReply,\n  isEditing,\n  setIsEditing,\n  onEdit,\n  onDelete,\n  onReply,\n  onLike,\n  isReplyingTo = false,\n  onReplyCancel,\n  replies = [],\n}: CleanVariantProps) {\n  const isCurrentUser = comment.author.id === currentUser.id;\n\n  return (\n    <div\n      className={`group py-4 ${\n        isReply ? \"ml-8 border-l border-l-gray-200 pl-6 bg-gray-50/20\" : \"\"\n      }`}\n    >\n      <div className=\"flex items-center gap-3 mb-2 pb-2 border-b border-gray-100\">\n        <div className=\"flex items-center gap-2 flex-1\">\n          {isReply && <span className=\"text-gray-400 text-sm\">↳</span>}\n          <span className=\"font-medium text-gray-900\">\n            {comment.author.name}\n          </span>\n          <span className=\"text-sm text-gray-300\">•</span>\n          <span className=\"text-sm text-gray-500\">\n            {formatTimeAgo(comment.createdAt)}\n          </span>\n          {isReply && (\n            <Badge\n              variant=\"outline\"\n              className=\"text-xs text-gray-500 border-gray-200 bg-white\"\n            >\n              Reply\n            </Badge>\n          )}\n        </div>\n      </div>\n\n      {isEditing ? (\n        <LexicalCommentComposer\n          variant=\"clean\"\n          placeholder=\"Edit your comment...\"\n          onSubmit={async (content: string, editorState: string) => {\n            if (onEdit) {\n              await onEdit(comment.id, content, editorState);\n              setIsEditing(false);\n            }\n          }}\n          className=\"border border-gray-200 rounded-lg\"\n          initialContent={comment.content}\n          initialEditorState={comment.editorState}\n        />\n      ) : (\n        <LexicalReadOnlyRenderer\n          editorState={comment.editorState}\n          content={comment.content}\n          className=\"text-sm text-gray-800 leading-relaxed mb-2\"\n        />\n      )}\n\n      <CommentActionBar\n        comment={comment}\n        currentUser={currentUser}\n        variant=\"clean\"\n        isReply={isReply}\n        isEditing={isEditing}\n        isOwner={isCurrentUser}\n        isReplyingTo={isReplyingTo}\n        onEdit={onEdit}\n        onDelete={onDelete}\n        onReply={onReply}\n        onReplyCancel={onReplyCancel}\n        onLike={onLike}\n        onToggleEdit={() => setIsEditing(!isEditing)}\n        replies={replies}\n      />\n\n      <CommentSourceReference\n        sourceReference={comment.sourceReference}\n        variant=\"clean\"\n      />\n    </div>\n  );\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/comments/variants/compact-variant.tsx",
      "content": "\"use client\"\nimport { LexicalCommentComposer } from \"@/lib/comments/components/lexical/lexical-comment-composer\"\nimport { LexicalReadOnlyRenderer } from \"@/lib/comments/components/lexical/lexical-read-only-renderer\"\nimport { CommentActionBar } from \"@/lib/comments/components/comments/comment-action-bar\"\nimport { CommentSourceReference } from \"../comment-source-reference\"\nimport type { Comment, User as UserType } from \"@/lib/comments/types/comments\"\n\ninterface CompactVariantProps {\n  comment: Comment\n  currentUser: UserType\n  isReply: boolean\n  isEditing: boolean\n  setIsEditing: (editing: boolean) => void\n  isReplyingTo?: boolean\n  onEdit?: (commentId: string, content: string, editorState: string) => void\n  onDelete?: () => void\n  onReply?: () => void\n  onReplyCancel?: () => void\n  onLike?: () => void\n  replies?: Comment[]\n}\n\nexport function CompactVariant({\n  comment,\n  currentUser,\n  isReply,\n  isEditing,\n  setIsEditing,\n  isReplyingTo = false,\n  onEdit,\n  onDelete,\n  onReply,\n  onReplyCancel,\n  onLike,\n  replies = [],\n}: CompactVariantProps) {\n  const handleEditSubmit = async (content: string, editorState: string) => {\n    if (onEdit) {\n      await onEdit(comment.id, content, editorState)\n      setIsEditing(false)\n    }\n  }\n\n  const isCurrentUser = comment.author.id === currentUser.id\n\n  return (\n    <div\n      className={`p-3 border rounded-lg bg-white ${isReply ? \"ml-6 border-l-2 border-l-green-200 bg-green-25\" : \"\"}`}\n    >\n      <div className=\"flex gap-2\">\n        <div className=\"flex-shrink-0\">\n          <div className=\"w-6 h-6 rounded-full bg-gray-200 flex items-center justify-center text-xs font-medium\">\n            {comment.author.name.charAt(0)}\n          </div>\n        </div>\n\n        <div className=\"flex-1 min-w-0\">\n          <div className=\"flex items-center gap-2 mb-1.5\">\n            <span className=\"text-sm font-medium text-gray-900\">{comment.author.name}</span>\n            <span className=\"text-xs text-gray-500\">{comment.author.role}</span>\n            {isReply && <span className=\"text-xs text-green-600\">↳</span>}\n            <span className=\"text-xs text-gray-400\">2m ago</span>\n          </div>\n\n          {isEditing ? (\n            <div className=\"mt-2\">\n              <LexicalCommentComposer\n                variant=\"compact\"\n                placeholder=\"Edit your comment...\"\n                onSubmit={handleEditSubmit}\n                className=\"min-h-[60px]\"\n                initialContent={comment.content}\n                initialEditorState={comment.editorState}\n              />\n            </div>\n          ) : (\n            <div className=\"text-sm text-gray-800\">\n              <LexicalReadOnlyRenderer content={comment.content} editorState={comment.editorState} />\n            </div>\n          )}\n\n          <CommentActionBar\n            comment={comment}\n            currentUser={currentUser}\n            variant=\"compact\"\n            isReply={isReply}\n            isEditing={isEditing}\n            isOwner={isCurrentUser}\n            isReplyingTo={isReplyingTo}\n            onEdit={onEdit}\n            onDelete={onDelete}\n            onReply={onReply}\n            onReplyCancel={onReplyCancel}\n            onLike={onLike}\n            onToggleEdit={() => setIsEditing(!isEditing)}\n            replies={replies}\n          />\n\n          <CommentSourceReference\n            sourceReference={comment.sourceReference}\n            variant=\"compact\"\n          />\n        </div>\n      </div>\n    </div>\n  )\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/comments/variants/email-variant.tsx",
      "content": "\"use client\"\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/components/ui/avatar\"\nimport type { Comment, User as UserType } from \"@/lib/comments/types/comments\"\nimport { formatTimeAgo } from '@/lib/comments/utils/formatTimeAgo'\nimport { LexicalCommentComposer } from \"@/lib/comments/components/lexical/lexical-comment-composer\"\nimport { LexicalReadOnlyRenderer } from \"@/lib/comments/components/lexical/lexical-read-only-renderer\"\nimport { CommentActionBar } from \"@/lib/comments/components/comments/comment-action-bar\"\nimport { CommentSourceReference } from \"../comment-source-reference\"\n\ninterface EmailVariantProps {\n  comment: Comment\n  currentUser: UserType\n  isReply: boolean\n  isEditing: boolean\n  setIsEditing: (editing: boolean) => void\n  isReplyingTo?: boolean\n  onEdit?: (commentId: string, content: string, editorState: string) => void\n  onDelete?: () => void\n  onReply?: () => void\n  onReplyCancel?: () => void\n  onForward?: () => void\n  replies?: Comment[]\n}\n\nexport function EmailVariant({\n  comment,\n  currentUser,\n  isReply,\n  isEditing,\n  setIsEditing,\n  isReplyingTo = false,\n  onEdit,\n  onDelete,\n  onReply,\n  onReplyCancel,\n  onForward,\n  replies = [],\n}: EmailVariantProps) {\n\n  const styles = {\n    container: \"border border-gray-300 rounded-none bg-white shadow-sm mb-1\",\n    replyContainer: \"ml-8 border-l-4 border-blue-400 bg-blue-50/20\",\n    content: \"divide-y divide-gray-200\",\n    header: \"bg-gray-100 px-4 py-3 border-b border-gray-300\",\n    body: \"px-4 py-4\",\n    avatar: \"h-8 w-8 flex-shrink-0 rounded-none\",\n    avatarFallback: \"bg-blue-600 text-white text-sm font-bold\",\n    name: \"font-bold text-gray-900\",\n    badge: \"text-xs px-2 py-1 bg-white border border-gray-400 rounded-none\",\n    timestamp: \"text-sm text-gray-700 font-medium\",\n    subject: \"font-semibold text-gray-900 mb-2\",\n    replyIcon: \"text-blue-600 font-bold\",\n    actions: \"flex items-center gap-4 mt-4 pt-3 border-t border-gray-300\",\n    actionButton: \"text-gray-700 hover:text-blue-600 font-medium text-sm underline\",\n  }\n\n  const getInitials = (name: string) => {\n    return name\n      .split(\" \")\n      .map((n) => n[0])\n      .join(\"\")\n      .toUpperCase()\n  }\n\n  const handleEditSubmit = async (content: string, editorState: string) => {\n    if (onEdit) {\n      await onEdit(comment.id, content, editorState)\n      setIsEditing(false)\n    }\n  }\n\n  const isCurrentUser = comment.author.id === currentUser.id\n\n  return (\n    <>\n      <div className={`${styles.container} ${isReply ? styles.replyContainer : \"\"}`}>\n        <div className=\"border-b border-gray-200 p-3 bg-gray-50 rounded-t-lg\">\n          <div className=\"space-y-1 text-sm\">\n            <div className=\"flex items-center gap-2\">\n              <span className=\"font-medium text-gray-600 w-12\">From:</span>\n              <div className=\"flex items-center gap-2\">\n                <Avatar className=\"h-5 w-5\">\n                  <AvatarImage src={comment.author.avatar || \"/placeholder.svg\"} alt={comment.author.name} />\n                  <AvatarFallback className=\"text-xs\">{getInitials(comment.author.name)}</AvatarFallback>\n                </Avatar>\n                <span className=\"font-medium\">{comment.author.name}</span>\n                <span className=\"text-gray-500\">&lt;{comment.author.email}&gt;</span>\n              </div>\n            </div>\n            <div className=\"flex items-center gap-2\">\n              <span className=\"font-medium text-gray-600 w-12\">Date:</span>\n              <span className=\"text-gray-700\">{formatTimeAgo(comment.createdAt)}</span>\n            </div>\n            <div className=\"flex items-center gap-2\">\n              <span className=\"font-medium text-gray-600 w-12\">Subject:</span>\n              <span className=\"text-gray-700\">{isReply ? \"Re: \" : \"\"}Comment on Item</span>\n            </div>\n          </div>\n        </div>\n        <div className=\"p-4\">\n          {isEditing ? (\n            <LexicalCommentComposer\n              variant=\"email\"\n              placeholder=\"Edit your comment...\"\n              onSubmit={handleEditSubmit}\n              className=\"border border-gray-300 rounded-md\"\n              initialContent={comment.content}\n              initialEditorState={comment.editorState}\n            />\n          ) : (\n            <LexicalReadOnlyRenderer\n              editorState={comment.editorState}\n              content={comment.content}\n              className=\"text-sm text-gray-800 leading-relaxed\"\n            />\n          )}\n\n          <CommentActionBar\n            comment={comment}\n            currentUser={currentUser}\n            variant=\"email\"\n            isReply={isReply}\n            isEditing={isEditing}\n            isOwner={isCurrentUser}\n            isReplyingTo={isReplyingTo}\n            onEdit={onEdit}\n            onDelete={onDelete}\n            onReply={onReply}\n            onReplyCancel={onReplyCancel}\n            onForward={onForward}\n            onToggleEdit={() => setIsEditing(!isEditing)}\n            replies={replies}\n          />\n\n          <CommentSourceReference\n            sourceReference={comment.sourceReference}\n            variant=\"email\"\n          />\n        </div>\n      </div>\n    </>\n  )\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/comments/variants/github-variant.tsx",
      "content": "\"use client\"\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/components/ui/avatar\"\nimport { Button } from \"@/components/ui/button\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { CircleX } from \"lucide-react\"\nimport type { Comment, User as UserType } from \"@/lib/comments/types/comments\"\nimport { formatTimeAgo } from '@/lib/comments/utils/formatTimeAgo'\nimport { LexicalCommentComposer } from \"@/lib/comments/components/lexical/lexical-comment-composer\"\nimport { LexicalReadOnlyRenderer } from \"@/lib/comments/components/lexical/lexical-read-only-renderer\"\nimport { CommentActionBar } from \"@/lib/comments/components/comments/comment-action-bar\"\nimport { CommentSourceReference } from \"../comment-source-reference\"\n\ninterface GitHubVariantProps {\n  comment: Comment\n  currentUser: UserType\n  isReply: boolean\n  isEditing: boolean\n  setIsEditing: (editing: boolean) => void\n  isReplyingTo?: boolean\n  onEdit?: (commentId: string, content: string, editorState: string) => void\n  onDelete?: () => void\n  onReply?: () => void\n  onReplyCancel?: () => void\n  onReact?: (reaction: string) => void\n  replies?: Comment[]\n}\n\nexport function GitHubVariant({\n  comment,\n  currentUser,\n  isReply,\n  isEditing,\n  setIsEditing,\n  isReplyingTo = false,\n  onEdit,\n  onDelete,\n  onReply,\n  onReplyCancel,\n  onReact,\n  replies = [],\n}: GitHubVariantProps) {\n\n  const styles = {\n    container: \"border border-gray-300 rounded-md bg-white\",\n    replyContainer: \"ml-8 mt-2 border-l-4 border-gray-300 bg-gray-50\",\n    actionButton: \"text-gray-600 hover:text-blue-600 text-sm flex items-center gap-1\",\n  }\n\n  const getInitials = (name: string) => {\n    return name\n      .split(\" \")\n      .map((n) => n[0])\n      .join(\"\")\n      .toUpperCase()\n  }\n\n  const handleEditSubmit = async (content: string, editorState: string) => {\n    if (onEdit) {\n      await onEdit(comment.id, content, editorState)\n      setIsEditing(false)\n    }\n  }\n\n  const isCurrentUser = comment.author.id === currentUser.id\n\n  return (\n    <>\n      <div className={`${styles.container} ${isReply ? styles.replyContainer : \"\"}`}>\n        <div className=\"flex items-center justify-between p-3 bg-gray-50 border-b border-gray-200 rounded-t-lg\">\n          <div className=\"flex items-center gap-2\">\n            <Avatar className=\"h-6 w-6\">\n              <AvatarImage src={comment.author.avatar || \"/placeholder.svg\"} alt={comment.author.name} />\n              <AvatarFallback className=\"text-xs bg-gray-200\">{getInitials(comment.author.name)}</AvatarFallback>\n            </Avatar>\n            <span className=\"text-sm font-medium text-gray-900\">{comment.author.name}</span>\n            <span className=\"text-xs text-gray-500\">commented {formatTimeAgo(comment.createdAt)}</span>\n            {isReply && (\n              <Badge variant=\"outline\" className=\"text-xs\">\n                Reply\n              </Badge>\n            )}\n          </div>\n          <div className=\"flex items-center gap-1\">\n            {isEditing ? (\n              <>\n                <Badge variant=\"secondary\" className=\"text-xs bg-blue-50 text-blue-700\">\n                  Editing\n                </Badge>\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  className={styles.actionButton + \" rounded-full h-6 w-6 cursor-pointer p-2\"}\n                  onClick={() => setIsEditing(false)}\n                >\n                  <CircleX className=\"h-4 w-4\" />\n                </Button>\n              </>\n            ) : null}\n            <Badge variant=\"outline\" className=\"text-xs bg-green-50 text-green-700 border-green-200 hidden\">\n              Approved\n            </Badge>\n          </div>\n        </div>\n        <div className=\"p-4\">\n          {isEditing ? (\n            <LexicalCommentComposer\n              variant=\"github\"\n              placeholder=\"Edit your comment...\"\n              onSubmit={handleEditSubmit}\n              className=\"border border-gray-300 rounded-md\"\n              initialContent={comment.content}\n              initialEditorState={comment.editorState}\n            />\n          ) : (\n            <LexicalReadOnlyRenderer\n              editorState={comment.editorState}\n              content={comment.content}\n              className=\"text-sm text-gray-800 leading-relaxed\"\n            />\n          )}\n\n          <CommentActionBar\n            comment={comment}\n            currentUser={currentUser}\n            variant=\"github\"\n            isReply={isReply}\n            isEditing={isEditing}\n            isOwner={isCurrentUser}\n            isReplyingTo={isReplyingTo}\n            onEdit={onEdit}\n            onDelete={onDelete}\n            onReply={onReply}\n            onReplyCancel={onReplyCancel}\n            onReact={onReact}\n            onToggleEdit={() => setIsEditing(!isEditing)}\n            replies={replies}\n          />\n\n          <CommentSourceReference\n            sourceReference={comment.sourceReference}\n            variant=\"github\"\n          />\n        </div>\n      </div>\n    </>\n  )\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/comments/variants/mobile-variant.tsx",
      "content": "\"use client\"\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/components/ui/avatar\"\nimport { Badge } from \"@/components/ui/badge\"\nimport type { Comment, User as UserType } from \"@/lib/comments/types/comments\"\nimport { formatTimeAgo } from '@/lib/comments/utils/formatTimeAgo'\nimport { LexicalCommentComposer } from \"@/lib/comments/components/lexical/lexical-comment-composer\"\nimport { LexicalReadOnlyRenderer } from \"@/lib/comments/components/lexical/lexical-read-only-renderer\"\nimport { CommentActionBar } from \"../comment-action-bar\"\nimport { CommentSourceReference } from \"../comment-source-reference\"\n\ninterface MobileVariantProps {\n  comment: Comment\n  currentUser: UserType\n  isReply: boolean\n  isEditing: boolean\n  setIsEditing: (editing: boolean) => void\n  onEdit?: (commentId: string, content: string, editorState: string) => void\n  onDelete?: () => void\n  onReply?: () => void\n  onLike?: () => void\n  isReplyingTo?: boolean\n  onReplyCancel?: () => void\n  replies?: Comment[]\n}\n\nexport function MobileVariant({\n  comment,\n  currentUser,\n  isReply,\n  isEditing,\n  setIsEditing,\n  onEdit,\n  onDelete,\n  onReply,\n  onLike,\n  isReplyingTo = false,\n  onReplyCancel,\n  replies = [],\n}: MobileVariantProps) {\n  const isCurrentUser = comment.author.id === currentUser.id\n\n  const getInitials = (name: string) => {\n    return name\n      .split(\" \")\n      .map((n) => n[0])\n      .join(\"\")\n      .toUpperCase()\n  }\n\n  return (\n    <>\n      <div\n        className={`border border-gray-200 rounded-xl bg-white shadow-sm ${isReply ? \"ml-4 border-l-4 border-l-blue-400 bg-blue-50/20\" : \"\"}`}\n      >\n        <div className=\"flex items-center gap-4 p-4 bg-gray-50 rounded-t-xl border-b border-gray-200\">\n          <Avatar className=\"h-12 w-12 ring-2 ring-blue-100\">\n            <AvatarImage src={comment.author.avatar || \"/placeholder.svg\"} alt={comment.author.name} />\n            <AvatarFallback className=\"bg-blue-100 text-blue-700 text-sm font-semibold\">\n              {getInitials(comment.author.name)}\n            </AvatarFallback>\n          </Avatar>\n          <div className=\"flex-1 min-w-0\">\n            <div className=\"flex items-center gap-2\">\n              {isReply && <span className=\"text-blue-600 font-medium text-sm\">↳</span>}\n              <span className=\"font-semibold text-gray-900 truncate\">{comment.author.name}</span>\n            </div>\n            <div className=\"flex items-center gap-2 mt-1\">\n              <Badge variant=\"outline\" className=\"text-xs px-2 py-1 bg-white\">\n                {comment.author.role}\n              </Badge>\n              <span className=\"text-sm text-gray-500\">{formatTimeAgo(comment.createdAt)}</span>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"p-4\">\n          {isEditing ? (\n            <LexicalCommentComposer\n              variant=\"mobile\"\n              placeholder=\"Edit your comment...\"\n              onSubmit={async (content: string, editorState: string) => {\n                if (onEdit) {\n                  await onEdit(comment.id, content, editorState)\n                  setIsEditing(false)\n                }\n              }}\n              className=\"border border-gray-300 rounded-lg\"\n              initialContent={comment.content}\n              initialEditorState={comment.editorState}\n            />\n          ) : (\n            <LexicalReadOnlyRenderer\n              editorState={comment.editorState}\n              content={comment.content}\n              className=\"text-base text-gray-800 leading-relaxed\"\n            />\n          )}\n\n          <CommentActionBar\n            comment={comment}\n            currentUser={currentUser}\n            variant=\"mobile\"\n            isReply={isReply}\n            isEditing={isEditing}\n            isOwner={isCurrentUser}\n            isReplyingTo={isReplyingTo}\n            onEdit={onEdit}\n            onDelete={onDelete}\n            onReply={onReply}\n            onReplyCancel={onReplyCancel}\n            onLike={onLike}\n            onToggleEdit={() => setIsEditing(!isEditing)}\n            replies={replies}\n          />\n\n          <CommentSourceReference\n            sourceReference={comment.sourceReference}\n            variant=\"mobile\"\n          />\n        </div>\n      </div>\n    </>\n  )\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/comments/variants/notion-variant.tsx",
      "content": "\"use client\"\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/components/ui/avatar\"\nimport { Badge } from \"@/components/ui/badge\"\nimport type { Comment, User as UserType } from \"@/lib/comments/types/comments\"\nimport { formatTimeAgo } from '@/lib/comments/utils/formatTimeAgo'\nimport { LexicalCommentComposer } from \"@/lib/comments/components/lexical/lexical-comment-composer\"\nimport { LexicalReadOnlyRenderer } from \"@/lib/comments/components/lexical/lexical-read-only-renderer\"\nimport { CommentActionBar } from \"@/lib/comments/components/comments/comment-action-bar\"\nimport { CommentSourceReference } from \"../comment-source-reference\"\n\ninterface NotionVariantProps {\n  comment: Comment\n  currentUser: UserType\n  isReply: boolean\n  isEditing: boolean\n  setIsEditing: (editing: boolean) => void\n  isReplyingTo?: boolean\n  onEdit?: (commentId: string, content: string, editorState: string) => void\n  onDelete?: () => void\n  onReply?: () => void\n  onReplyCancel?: () => void\n  onLike?: () => void\n  replies?: Comment[]\n}\n\nexport function NotionVariant({\n  comment,\n  currentUser,\n  isReply,\n  isEditing,\n  setIsEditing,\n  isReplyingTo = false,\n  onEdit,\n  onDelete,\n  onReply,\n  onReplyCancel,\n  onLike,\n  replies = [],\n}: NotionVariantProps) {\n  const getInitials = (name: string) => {\n    return name\n      .split(\" \")\n      .map((n) => n[0])\n      .join(\"\")\n      .toUpperCase()\n  }\n\n  const isCurrentUser = comment.author.id === currentUser.id\n\n  return (\n    <>\n      <div\n        className={`group p-3 hover:bg-gray-25 transition-colors duration-150 rounded-lg ${isReply ? \"ml-6 border-l-2 border-l-orange-300 pl-4 bg-orange-50/30\" : \"\"}`}\n      >\n        <div className=\"flex gap-3\">\n          <Avatar className=\"h-7 w-7 flex-shrink-0\">\n            <AvatarImage src={comment.author.avatar || \"/placeholder.svg\"} alt={comment.author.name} />\n            <AvatarFallback className=\"bg-orange-100 text-orange-700 text-xs font-medium\">\n              {getInitials(comment.author.name)}\n            </AvatarFallback>\n          </Avatar>\n          <div className=\"flex-1 min-w-0\">\n            <div className=\"flex items-center gap-2 mb-2\">\n              {isReply && <span className=\"text-orange-600 text-sm font-medium\">↳</span>}\n              <span className=\"font-medium text-gray-900 text-sm\">{comment.author.name}</span>\n              <Badge variant=\"outline\" className=\"text-xs px-1.5 py-0 bg-orange-50 border-orange-200 text-orange-700\">\n                {comment.author.role}\n              </Badge>\n              <span className=\"text-xs text-gray-500\">{formatTimeAgo(comment.createdAt)}</span>\n            </div>\n\n            {isEditing ? (\n              <LexicalCommentComposer\n                variant=\"notion\"\n                placeholder=\"Edit your comment...\"\n                onSubmit={async (content: string, editorState: string) => {\n                  if (onEdit) {\n                    await onEdit(comment.id, content, editorState)\n                    setIsEditing(false)\n                  }\n                }}\n                className=\"border border-gray-300 rounded-md\"\n                initialContent={comment.content}\n                initialEditorState={comment.editorState}\n              />\n            ) : (\n              <div className=\"border-l-3 border-l-gray-300 pl-3 py-1 bg-gray-50/50 rounded-r-md\">\n                <LexicalReadOnlyRenderer\n                  editorState={comment.editorState}\n                  content={comment.content}\n                  className=\"text-sm text-gray-800 leading-relaxed\"\n                />\n              </div>\n            )}\n\n            <CommentActionBar\n              comment={comment}\n              currentUser={currentUser}\n              variant=\"notion\"\n              isReply={isReply}\n              isEditing={isEditing}\n              isOwner={isCurrentUser}\n              isReplyingTo={isReplyingTo}\n              onEdit={onEdit}\n              onDelete={onDelete}\n              onReply={onReply}\n              onReplyCancel={onReplyCancel}\n              onLike={onLike}\n              onToggleEdit={() => setIsEditing(!isEditing)}\n              replies={replies}\n            />\n\n            <CommentSourceReference\n              sourceReference={comment.sourceReference}\n              variant=\"notion\"\n            />\n          </div>\n        </div>\n      </div>\n    </>\n  )\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/comments/variants/plain-variant.tsx",
      "content": "\"use client\"\nimport type { Comment, User as UserType } from \"@/lib/comments/types/comments\"\nimport { LexicalReadOnlyRenderer } from \"@/lib/comments/components/lexical/lexical-read-only-renderer\"\nimport { LexicalCommentComposer } from \"@/lib/comments/components/lexical/lexical-comment-composer\"\nimport { CommentActionBar } from \"../comment-action-bar\"\nimport { CommentSourceReference } from \"../comment-source-reference\"\n\ninterface PlainVariantProps {\n  comment: Comment\n  currentUser: UserType\n  isReply: boolean\n  isEditing: boolean\n  setIsEditing: (editing: boolean) => void\n  onEdit?: (commentId: string, content: string, editorState: string) => void\n  onDelete?: () => void\n  onReply?: () => void\n  onLike?: () => void\n  isReplyingTo?: boolean\n  onReplyCancel?: () => void\n  replies?: Comment[]\n}\n\nexport function PlainVariant({\n  comment,\n  currentUser,\n  isReply,\n  isEditing,\n  setIsEditing,\n  onEdit,\n  onDelete,\n  onReply,\n  onLike,\n  isReplyingTo = false,\n  onReplyCancel,\n  replies = [],\n}: PlainVariantProps) {\n  const isCurrentUser = comment.author.id === currentUser.id\n\n  const handleEditSubmit = async (content: string, editorState: string) => {\n    if (onEdit) {\n      await onEdit(comment.id, content, editorState)\n      setIsEditing(false)\n    }\n  }\n  return (\n    <div\n      className={`p-4 border border-gray-200 rounded-lg bg-white ${isReply ? \"ml-4 border-l-2 border-l-gray-300\" : \"\"}`}\n    >\n      <div className=\"flex gap-3\">\n        <div className=\"flex-1\">\n          <div className=\"flex items-center gap-2 mb-2\">\n            <span className=\"font-medium\">{comment.author.name}</span>\n            {isReply && <span className=\"text-gray-400\">↳</span>}\n          </div>\n          {isEditing ? (\n            <LexicalCommentComposer\n              variant=\"plain\"\n              placeholder=\"Edit your comment...\"\n              onSubmit={handleEditSubmit}\n              className=\"border border-gray-300 rounded-md\"\n              initialContent={comment.content}\n              initialEditorState={comment.editorState}\n            />\n          ) : (\n            <div className=\"text-sm text-gray-800\">\n              <LexicalReadOnlyRenderer content={comment.content} editorState={comment.editorState} />\n            </div>\n          )}\n          \n          <CommentActionBar\n            comment={comment}\n            currentUser={currentUser}\n            variant=\"plain\"\n            isReply={isReply}\n            isEditing={isEditing}\n            isOwner={isCurrentUser}\n            isReplyingTo={isReplyingTo}\n            onEdit={onEdit}\n            onDelete={onDelete}\n            onReply={onReply}\n            onReplyCancel={onReplyCancel}\n            onLike={onLike}\n            onToggleEdit={() => setIsEditing(!isEditing)}\n            replies={replies}\n          />\n\n          <CommentSourceReference\n            sourceReference={comment.sourceReference}\n            variant=\"plain\"\n          />\n        </div>\n      </div>\n    </div>\n  )\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/comments/variants/professional-variant.tsx",
      "content": "\"use client\"\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/components/ui/avatar\"\nimport { Badge } from \"@/components/ui/badge\"\nimport type { Comment, User as UserType } from \"@/lib/comments/types/comments\"\nimport { formatTimeAgo } from '@/lib/comments/utils/formatTimeAgo'\nimport { LexicalCommentComposer } from \"@/lib/comments/components/lexical/lexical-comment-composer\"\nimport { LexicalReadOnlyRenderer } from \"@/lib/comments/components/lexical/lexical-read-only-renderer\"\nimport { CommentActionBar } from \"@/lib/comments/components/comments/comment-action-bar\"\nimport { CommentSourceReference } from \"../comment-source-reference\"\n\ninterface ProfessionalVariantProps {\n  comment: Comment\n  currentUser: UserType\n  isReply: boolean\n  isEditing: boolean\n  setIsEditing: (editing: boolean) => void\n  isReplyingTo?: boolean\n  onEdit?: (commentId: string, content: string, editorState: string) => void\n  onDelete?: () => void\n  onReply?: () => void\n  onReplyCancel?: () => void\n  onApprove?: () => void\n  replies?: Comment[]\n}\n\nexport function ProfessionalVariant({\n  comment,\n  currentUser,\n  isReply,\n  isEditing,\n  setIsEditing,\n  isReplyingTo = false,\n  onEdit,\n  onDelete,\n  onReply,\n  onReplyCancel,\n  onApprove,\n  replies = [],\n}: ProfessionalVariantProps) {\n  const getInitials = (name: string) => {\n    return name\n      .split(\" \")\n      .map((n) => n[0])\n      .join(\"\")\n      .toUpperCase()\n  }\n\n  const isCurrentUser = comment.author.id === currentUser.id\n\n  return (\n    <>\n      <div\n        className={`border border-slate-200 rounded bg-white shadow-sm ${isReply ? \"ml-8 border-l-4 border-l-slate-300 bg-slate-50\" : \"\"}`}\n      >\n        <div className=\"flex items-center justify-between p-4 bg-slate-50 border-b border-slate-200 rounded-t\">\n          <div className=\"flex items-center gap-3\">\n            <Avatar className=\"h-9 w-9 ring-2 ring-white\">\n              <AvatarImage src={comment.author.avatar || \"/placeholder.svg\"} alt={comment.author.name} />\n              <AvatarFallback className=\"bg-slate-200 text-slate-700 text-sm font-medium\">\n                {getInitials(comment.author.name)}\n              </AvatarFallback>\n            </Avatar>\n            <div>\n              <div className=\"flex items-center gap-2\">\n                <span className=\"font-semibold text-slate-900\">{comment.author.name}</span>\n                <Badge variant=\"outline\" className=\"text-xs bg-white border-slate-300 text-slate-600\">\n                  {comment.author.role}\n                </Badge>\n                {isReply && <span className=\"text-xs text-slate-500\">• Reply</span>}\n              </div>\n              <div className=\"text-xs text-slate-500 mt-0.5\">{formatTimeAgo(comment.createdAt)}</div>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"p-4\">\n          {isEditing ? (\n            <LexicalCommentComposer\n              variant=\"professional\"\n              placeholder=\"Edit your comment...\"\n              onSubmit={async (content: string, editorState: string) => {\n                if (onEdit) {\n                  await onEdit(comment.id, content, editorState)\n                  setIsEditing(false)\n                }\n              }}\n              className=\"border border-slate-300 rounded-lg\"\n              initialContent={comment.content}\n              initialEditorState={comment.editorState}\n            />\n          ) : (\n            <LexicalReadOnlyRenderer\n              editorState={comment.editorState}\n              content={comment.content}\n              className=\"text-sm text-slate-800 leading-relaxed\"\n            />\n          )}\n\n          <CommentActionBar\n            comment={comment}\n            currentUser={currentUser}\n            variant=\"professional\"\n            isReply={isReply}\n            isEditing={isEditing}\n            isOwner={isCurrentUser}\n            isReplyingTo={isReplyingTo}\n            onEdit={onEdit}\n            onDelete={onDelete}\n            onReply={onReply}\n            onReplyCancel={onReplyCancel}\n            onApprove={onApprove}\n            onToggleEdit={() => setIsEditing(!isEditing)}\n            replies={replies}\n          />\n\n          <CommentSourceReference\n            sourceReference={comment.sourceReference}\n            variant=\"professional\"\n          />\n        </div>\n      </div>\n    </>\n  )\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/comments/variants/social-variant.tsx",
      "content": "\"use client\"\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/components/ui/avatar\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { formatTimeAgo } from '@/lib/comments/utils/formatTimeAgo'\nimport { LexicalCommentComposer } from \"@/lib/comments/components/lexical/lexical-comment-composer\"\nimport { LexicalReadOnlyRenderer } from \"@/lib/comments/components/lexical/lexical-read-only-renderer\"\nimport { CommentActionBar } from \"@/lib/comments/components/comments/comment-action-bar\"\nimport { CommentSourceReference } from \"../comment-source-reference\"\nimport type { Comment, User as UserType } from \"@/lib/comments/types/comments\"\n\ninterface SocialVariantProps {\n  comment: Comment\n  currentUser: UserType\n  isReply: boolean\n  isEditing: boolean\n  setIsEditing: (editing: boolean) => void\n  isReplyingTo?: boolean\n  onEdit?: (commentId: string, content: string, editorState: string) => void\n  onDelete: () => void\n  onReply: () => void\n  onReplyCancel?: () => void\n  onLike: () => void\n  onShare: () => void\n  replies?: Comment[]\n}\n\nexport function SocialVariant({\n  comment,\n  currentUser,\n  isReply,\n  isEditing,\n  setIsEditing,\n  isReplyingTo = false,\n  onEdit,\n  onDelete,\n  onReply,\n  onReplyCancel,\n  onLike,\n  onShare,\n  replies = [],\n}: SocialVariantProps) {\n  const styles = {\n    container: \"bg-white border border-gray-200 rounded-xl p-4 hover:shadow-lg transition-all duration-200\",\n    replyContainer: \"ml-12 mt-3 bg-gray-50 border border-gray-100 rounded-lg\",\n    content: \"space-y-3\",\n    avatar: \"h-12 w-12 flex-shrink-0 ring-2 ring-white shadow-md\",\n    avatarFallback: \"bg-gradient-to-br from-purple-400 to-pink-400 text-white font-semibold\",\n    name: \"font-bold text-gray-900 text-lg\",\n    badge: \"text-xs px-3 py-1 bg-gradient-to-r from-blue-500 to-purple-500 text-white rounded-full\",\n    timestamp: \"text-sm text-gray-500 font-medium\",\n    replyIcon: \"text-purple-500 font-bold\",\n    actions: \"flex items-center gap-4 pt-3 border-t border-gray-100\",\n    actionButton: \"text-gray-600 hover:text-purple-600 font-medium flex items-center gap-2\",\n    likeCount: \"bg-red-50 text-red-600 px-2 py-1 rounded-full text-xs font-medium\",\n  }\n\n  const getInitials = (name: string) => {\n    return name\n      .split(\" \")\n      .map((n) => n[0])\n      .join(\"\")\n      .toUpperCase()\n  }\n\n  const handleEditSubmit = async (content: string, editorState: string) => {\n    if (onEdit) {\n      await onEdit(comment.id, content, editorState)\n      setIsEditing(false)\n    }\n  }\n\n  const isCurrentUser = comment.author.id === currentUser.id\n\n  return (\n    <div className={`${styles.container} ${isReply ? styles.replyContainer : \"\"}`}>\n      <div className={styles.content}>\n        <div className=\"flex gap-3\">\n          <Avatar className={styles.avatar}>\n            <AvatarImage src={comment.author.avatar || \"/placeholder.svg\"} alt={comment.author.name} />\n            <AvatarFallback className={styles.avatarFallback}>{getInitials(comment.author.name)}</AvatarFallback>\n          </Avatar>\n          <div className=\"flex-1\">\n            <div className=\"flex items-center gap-2 mb-2\">\n              {isReply && <span className={styles.replyIcon}>↳</span>}\n              <span className={styles.name}>{comment.author.name}</span>\n              <Badge className={styles.badge}>{comment.author.role}</Badge>\n              <span className={styles.timestamp}>{formatTimeAgo(comment.createdAt)}</span>\n            </div>\n            {isEditing ? (\n              <div className=\"space-y-2\">\n                <LexicalCommentComposer\n                  variant=\"social\"\n                  placeholder=\"Edit your comment...\"\n                  onSubmit={handleEditSubmit}\n                  className=\"border border-gray-300 rounded-md\"\n                  initialContent={comment.content}\n                  initialEditorState={comment.editorState}\n                />\n              </div>\n            ) : (\n              <>\n                <LexicalReadOnlyRenderer\n                  editorState={comment.editorState}\n                  content={comment.content}\n                  className=\"text-sm text-gray-800 leading-relaxed\"\n                />\n\n              </>\n            )}\n          </div>\n        </div>\n\n        <CommentActionBar\n          comment={comment}\n          currentUser={currentUser}\n          variant=\"social\"\n          isReply={isReply}\n          isEditing={isEditing}\n          isOwner={isCurrentUser}\n          isReplyingTo={isReplyingTo}\n          onEdit={onEdit}\n          onDelete={onDelete}\n          onReply={onReply}\n          onReplyCancel={onReplyCancel}\n          onLike={onLike}\n          onShare={onShare}\n          onToggleEdit={() => setIsEditing(!isEditing)}\n          replies={replies}\n        />\n\n        <CommentSourceReference\n          sourceReference={comment.sourceReference}\n          variant=\"social\"\n        />\n      </div>\n    </div>\n  )\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/comments/variants/thread-variant.tsx",
      "content": "\"use client\"\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/components/ui/avatar\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { formatTimeAgo } from '@/lib/comments/utils/formatTimeAgo'\nimport { LexicalCommentComposer } from \"@/lib/comments/components/lexical/lexical-comment-composer\"\nimport { LexicalReadOnlyRenderer } from \"@/lib/comments/components/lexical/lexical-read-only-renderer\"\nimport { CommentActionBar } from \"@/lib/comments/components/comments/comment-action-bar\"\nimport { CommentSourceReference } from \"../comment-source-reference\"\nimport type { Comment, User as UserType } from \"@/lib/comments/types/comments\"\n\ninterface ThreadVariantProps {\n  comment: Comment\n  currentUser: UserType\n  isReply: boolean\n  isEditing: boolean\n  setIsEditing: (editing: boolean) => void\n  isReplyingTo?: boolean\n  onEdit?: (commentId: string, content: string, editorState: string) => void\n  onDelete: () => void\n  onReply: () => void\n  onReplyCancel?: () => void\n  onLike: () => void\n  replies?: Comment[]\n}\n\nexport function ThreadVariant({\n  comment,\n  currentUser,\n  isReply,\n  isEditing,\n  setIsEditing,\n  isReplyingTo = false,\n  onEdit,\n  onDelete,\n  onReply,\n  onReplyCancel,\n  onLike,\n  replies = [],\n}: ThreadVariantProps) {\n  const getInitials = (name: string) => {\n    return name\n      .split(\" \")\n      .map((n) => n[0])\n      .join(\"\")\n      .toUpperCase()\n  }\n\n  const handleEditSubmit = async (content: string, editorState: string) => {\n    if (onEdit) {\n      await onEdit(comment.id, content, editorState)\n      setIsEditing(false)\n    }\n  }\n\n  const isCurrentUser = comment.author.id === currentUser.id\n\n  return (\n    <div\n      className={`group hover:bg-gray-25 transition-colors duration-150 ${\n        isReply ? \"ml-12 border-l-3 border-l-blue-300 pl-6 bg-blue-50/30 rounded-r-lg\" : \"\"\n      }`}\n    >\n      {isReply && <div className=\"absolute -ml-6 mt-4 w-4 h-px bg-blue-300\"></div>}\n      <div className=\"flex gap-3 py-2\">\n        <Avatar className=\"h-9 w-9 flex-shrink-0\">\n          <AvatarImage src={comment.author.avatar || \"/placeholder.svg\"} alt={comment.author.name} />\n          <AvatarFallback className=\"bg-gray-100 text-gray-700 text-sm font-medium\">\n            {getInitials(comment.author.name)}\n          </AvatarFallback>\n        </Avatar>\n        <div className=\"flex-1 min-w-0\">\n          <div className=\"flex items-baseline gap-2 mb-1\">\n            {isReply && <span className=\"text-xs text-blue-600 font-medium\">↳</span>}\n            <span className=\"font-semibold text-gray-900 text-sm\">{comment.author.name}</span>\n            <Badge variant=\"outline\" className=\"text-xs px-1.5 py-0 bg-white border-gray-200\">\n              {comment.author.role}\n            </Badge>\n            <span className=\"text-xs text-gray-500\">{formatTimeAgo(comment.createdAt)}</span>\n            {isEditing && <Badge className=\"text-xs bg-blue-50 text-blue-700 border border-blue-200\">editing</Badge>}\n          </div>\n\n          {isEditing ? (\n            <LexicalCommentComposer\n              variant=\"thread\"\n              placeholder=\"Edit your comment...\"\n              onSubmit={handleEditSubmit}\n              className=\"border border-gray-300 rounded-md\"\n              initialContent={comment.content}\n              initialEditorState={comment.editorState}\n            />\n          ) : (\n            <LexicalReadOnlyRenderer\n              editorState={comment.editorState}\n              content={comment.content}\n              className=\"text-sm text-gray-800 leading-relaxed\"\n            />\n          )}\n\n          <CommentActionBar\n            comment={comment}\n            currentUser={currentUser}\n            variant=\"thread\"\n            isReply={isReply}\n            isEditing={isEditing}\n            isOwner={isCurrentUser}\n            isReplyingTo={isReplyingTo}\n            onEdit={onEdit}\n            onDelete={onDelete}\n            onReply={onReply}\n            onReplyCancel={onReplyCancel}\n            onLike={onLike}\n            onToggleEdit={() => setIsEditing(!isEditing)}\n            replies={replies}\n          />\n\n          <CommentSourceReference\n            sourceReference={comment.sourceReference}\n            variant=\"thread\"\n          />\n        </div>\n      </div>\n    </div>\n  )\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/comments/variants/timeline-variant.tsx",
      "content": "\"use client\"\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/components/ui/avatar\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { formatTimeAgo } from '@/lib/comments/utils/formatTimeAgo'\nimport { LexicalCommentComposer } from \"@/lib/comments/components/lexical/lexical-comment-composer\"\nimport { LexicalReadOnlyRenderer } from \"@/lib/comments/components/lexical/lexical-read-only-renderer\"\nimport { CommentActionBar } from \"../comment-action-bar\"\nimport { CommentSourceReference } from \"../comment-source-reference\"\nimport type { Comment, User as UserType } from \"@/lib/comments/types/comments\"\n\ninterface TimelineVariantProps {\n  comment: Comment\n  currentUser: UserType\n  isReply: boolean\n  isEditing: boolean\n  setIsEditing: (editing: boolean) => void\n  onEdit?: (commentId: string, content: string, editorState: string) => void\n  onDelete: () => void\n  onReply: () => void\n  onLike: () => void\n  isReplyingTo?: boolean\n  onReplyCancel?: () => void\n  replies?: Comment[]\n}\n\nexport function TimelineVariant({\n  comment,\n  currentUser,\n  isReply,\n  isEditing,\n  setIsEditing,\n  onEdit,\n  onDelete,\n  onReply,\n  onLike,\n  isReplyingTo = false,\n  onReplyCancel,\n  replies = [],\n}: TimelineVariantProps) {\n  const styles = {\n    container: \"relative pl-12 pb-6 last:pb-0\",\n    mainTimeline: \"absolute left-6 top-0 bottom-0 w-0.5 bg-gradient-to-b from-blue-200 via-blue-300 to-blue-200\",\n    replyTimeline: \"absolute left-6 top-8 bottom-0 w-0.5 bg-gradient-to-b from-green-200 via-green-300 to-green-200\",\n    content:\n      \"relative bg-white border border-gray-200 rounded-xl p-5 shadow-sm hover:shadow-md transition-shadow duration-200 ml-6\",\n    replyContent:\n      \"relative bg-gradient-to-br from-green-50 to-white border border-green-200 rounded-xl p-4 shadow-sm hover:shadow-md transition-shadow duration-200 ml-12\",\n    timelineNode: \"absolute left-4 top-6 w-4 h-4 rounded-full border-3 border-white shadow-md z-10\",\n    parentNode: \"bg-gradient-to-br from-blue-500 to-blue-600\",\n    replyNode: \"bg-gradient-to-br from-green-500 to-green-600\",\n    connector: \"absolute left-7 top-8 w-6 h-0.5 bg-gradient-to-r from-green-300 to-transparent\",\n    name: \"font-semibold text-gray-900\",\n    badge: \"text-xs px-2 py-1 bg-blue-50 text-blue-700 rounded-full border border-blue-200\",\n    timestamp: \"text-sm text-gray-500 font-medium\",\n    actions: \"flex items-center gap-3 mt-4 pt-4 border-t border-gray-100\",\n    actionButton: \"text-gray-500 hover:text-blue-600 transition-colors duration-150\",\n  }\n\n  const getInitials = (name: string) => {\n    return name\n      .split(\" \")\n      .map((n) => n[0])\n      .join(\"\")\n      .toUpperCase()\n  }\n\n  const isCurrentUser = comment.author.id === currentUser.id\n\n  const handleEditSubmit = async (content: string, editorState: string) => {\n    if (onEdit) {\n      await onEdit(comment.id, content, editorState)\n      setIsEditing(false)\n    }\n  }\n\n  return (\n    <div className={styles.container}>\n      <div className={isReply ? styles.replyTimeline : styles.mainTimeline}></div>\n\n      <div className={`${styles.timelineNode} ${isReply ? styles.replyNode : styles.parentNode}`}></div>\n\n      {isReply && <div className={styles.connector}></div>}\n\n      <div className={isReply ? styles.replyContent : styles.content}>\n        <div className=\"flex items-start gap-3 mb-4\">\n          <Avatar className=\"h-10 w-10 ring-2 ring-white shadow-sm\">\n            <AvatarImage src={comment.author.avatar || \"/placeholder.svg\"} alt={comment.author.name} />\n            <AvatarFallback className=\"bg-gradient-to-br from-blue-100 to-blue-200 text-blue-700 text-sm font-semibold\">\n              {getInitials(comment.author.name)}\n            </AvatarFallback>\n          </Avatar>\n          <div className=\"flex-1 min-w-0\">\n            <div className=\"flex items-center gap-2 flex-wrap\">\n              {isReply && <span className=\"text-green-600 font-bold text-lg\">↳</span>}\n              <span className={styles.name}>{comment.author.name}</span>\n              <Badge variant=\"outline\" className={styles.badge}>\n                {comment.author.role}\n              </Badge>\n            </div>\n            <div className=\"flex items-center gap-2 mt-1\">\n              <span className={styles.timestamp}>{formatTimeAgo(comment.createdAt)}</span>\n              {isReply && (\n                <span className=\"text-xs text-green-600 bg-green-50 px-2 py-0.5 rounded-full border border-green-200\">\n                  Reply\n                </span>\n              )}\n            </div>\n          </div>\n        </div>\n\n        {isEditing ? (\n          <LexicalCommentComposer\n            variant=\"timeline\"\n            placeholder=\"Edit your comment...\"\n            onSubmit={handleEditSubmit}\n            className=\"border border-gray-300 rounded-md\"\n            initialContent={comment.content}\n            initialEditorState={comment.editorState}\n          />\n        ) : (\n          <LexicalReadOnlyRenderer\n            editorState={comment.editorState}\n            content={comment.content}\n            className=\"text-gray-800 leading-relaxed mb-4\"\n          />\n        )}\n\n        <CommentActionBar\n          comment={comment}\n          currentUser={currentUser}\n          variant=\"timeline\"\n          isReply={isReply}\n          isEditing={isEditing}\n          isOwner={isCurrentUser}\n          isReplyingTo={isReplyingTo}\n          onEdit={onEdit}\n          onDelete={onDelete}\n          onReply={onReply}\n          onReplyCancel={onReplyCancel}\n          onLike={onLike}\n          onToggleEdit={() => setIsEditing(!isEditing)}\n          replies={replies}\n        />\n\n        <CommentSourceReference\n          sourceReference={comment.sourceReference}\n          variant=\"timeline\"\n        />\n      </div>\n    </div>\n  )\n}\n"
    },
    {
      "type": "registry:lib",
      "path": "lib/components/lexical/config/lexical-config.ts",
      "content": "import { ListItemNode, ListNode } from \"@lexical/list\"\nimport { LinkNode, AutoLinkNode } from \"@lexical/link\"\nimport { createBeautifulMentionNode, type BeautifulMentionsTheme } from \"lexical-beautiful-mentions\"\nimport { CustomMentionComponent } from \"../mention-component\"\n\nexport const URL_MATCHER =\n  /((https?:\\/\\/(www\\.)?)|(www\\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/\n\nexport const EMAIL_MATCHER =\n  /(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/\n\nexport const MATCHERS = [\n  (text: string) => {\n    const match = URL_MATCHER.exec(text)\n    if (match === null) {\n      return null\n    }\n    const fullMatch = match[0]\n    return {\n      index: match.index,\n      length: fullMatch.length,\n      text: fullMatch,\n      url: fullMatch.startsWith(\"http\") ? fullMatch : `https://${fullMatch}`,\n      attributes: { rel: \"noreferrer\", target: \"_blank\" },\n    }\n  },\n  (text: string) => {\n    const match = EMAIL_MATCHER.exec(text)\n    if (match === null) {\n      return null\n    }\n    const fullMatch = match[0]\n    return {\n      index: match.index,\n      length: fullMatch.length,\n      text: fullMatch,\n      url: `mailto:${fullMatch}`,\n    }\n  },\n]\n\nexport function validateUrl(url: string): boolean {\n  return url === \"https://\" || URL_MATCHER.test(url) || EMAIL_MATCHER.test(url)\n}\n\nexport const lexicalTheme = {\n  ltr: \"ltr\",\n  rtl: \"rtl\",\n  placeholder: \"editor-placeholder\",\n  paragraph: \"mb-1\",\n  link: \"text-blue-600 hover:text-blue-800 underline cursor-pointer\",\n  list: {\n    listitem: \"mx-2\",\n    nested: {\n      listitem: \"mx-4\",\n    },\n    olDepth: [\n      \"list-decimal ml-4 space-y-1\",\n      \"list-decimal ml-6 space-y-1\",\n      \"list-decimal ml-8 space-y-1\",\n      \"list-decimal ml-10 space-y-1\",\n      \"list-decimal ml-12 space-y-1\",\n    ],\n    ul: \"list-disc ml-4 space-y-1\",\n  },\n  beautifulMentions: {\n    \"@\": \"mention-user\",\n    \"#\": \"mention-tag\",\n  } as BeautifulMentionsTheme,\n}\n\nexport const lexicalReadOnlyTheme = {\n  ...lexicalTheme,\n  list: {\n    listitem: \"my-2 ml-2\",\n    nested: {\n      listitem: \"my-1 ml-4\",\n    },\n    olDepth: [\n      \"list-decimal ml-4 space-y-1\",\n      \"list-[lower-alpha] ml-6 space-y-1\",\n      \"list-[lower-roman] ml-8 space-y-1\",\n      \"list-decimal ml-10 space-y-1\",\n      \"list-[lower-alpha] ml-12 space-y-1\",\n    ],\n    ul: \"list-disc ml-4 space-y-1\",\n  },\n}\n\nexport const lexicalNodes = [\n  ...createBeautifulMentionNode(CustomMentionComponent),\n  ListNode,\n  ListItemNode,\n  LinkNode,\n  AutoLinkNode,\n]\n\nexport const mentionItems = {\n  \"@\": [],\n  \"#\": [],\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/lexical/lexical-comment-composer.tsx",
      "content": "\"use client\";\n\nimport { forwardRef, useEffect, useState, useRef } from \"react\";\nimport { debug } from \"@/lib/comments/utils/debug\";\nimport { LexicalComposer } from \"@lexical/react/LexicalComposer\";\nimport { RichTextPlugin } from \"@lexical/react/LexicalRichTextPlugin\";\nimport { ContentEditable } from \"@lexical/react/LexicalContentEditable\";\nimport { HistoryPlugin } from \"@lexical/react/LexicalHistoryPlugin\";\nimport { LexicalErrorBoundary } from \"@lexical/react/LexicalErrorBoundary\";\nimport { ListPlugin } from \"@lexical/react/LexicalListPlugin\";\nimport { CheckListPlugin } from \"@lexical/react/LexicalCheckListPlugin\";\nimport { AutoLinkPlugin } from \"@lexical/react/LexicalAutoLinkPlugin\";\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport { $getRoot, $createParagraphNode, $createTextNode } from \"lexical\";\nimport {\n  BeautifulMentionsPlugin,\n  type BeautifulMentionsMenuProps,\n  type BeautifulMentionsMenuItemProps,\n} from \"lexical-beautiful-mentions\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport {\n  Send,\n  User,\n  Hash,\n  FileText,\n  BookOpen,\n  Tag,\n  HelpCircle,\n} from \"lucide-react\";\nimport { AutoListPlugin } from \"./plugins/auto-list-plugin\";\nimport { EmojiPlugin } from \"./plugins/emoji-plugin\";\nimport { KeyboardShortcutPlugin } from \"./plugins/keyboard-shortcut-plugin\";\nimport { FocusManagementPlugin } from \"./plugins/focus-management-plugin\";\nimport {\n  getContainerStyles,\n  getContentEditableStyles,\n  getPlaceholderPosition,\n  getButtonConfig,\n} from \"./utils/style-utils\";\nimport { useMentions } from \"@/lib/comments/contexts/mention-context\";\nimport { useComments } from \"@/lib/comments/contexts/comment-context\";\nimport { lexicalTheme, lexicalNodes, MATCHERS } from \"./config/lexical-config\";\nimport { CommentVariant, MentionTag, MentionUser } from \"@/lib/comments/types/comments\";\n\nconst CustomMenu = forwardRef<HTMLUListElement, BeautifulMentionsMenuProps>(\n  ({ loading, ...props }, ref) => {\n    // The `loading` prop is passed for consistency with other variants,\n    // but is not used in this component.\n    if (loading) {\n      // do nothing\n    }\n    return (\n      <ul\n        className=\"absolute z-50 mt-1 max-h-60 w-72 overflow-auto rounded-md border border-gray-200 bg-white py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none\"\n        {...props}\n        ref={ref}\n      />\n    );\n  }\n);\nCustomMenu.displayName = \"BeautifulMentionsCustomMenu\";\n\nconst CustomMenuItem = forwardRef<\n  HTMLLIElement,\n  BeautifulMentionsMenuItemProps\n>(({ selected, item, itemValue, ...props }, ref) => {\n  // The `itemValue` prop is passed for consistency with other variants,\n  // but is not used in this component.\n  if (itemValue) {\n    // do nothing\n  }\n  const getIcon = () => {\n    if (item.trigger === \"@\") return <User className=\"w-4 h-4 text-blue-600\" />;\n    if (item.trigger === \"#\") {\n      if (!item.value) return <Tag className=\"w-4 h-4 text-gray-600\" />;\n      if (item.value.startsWith(\"question\"))\n        return <FileText className=\"w-4 h-4 text-green-600\" />;\n      if (item.value.startsWith(\"rule\"))\n        return <BookOpen className=\"w-4 h-4 text-purple-600\" />;\n      if (item.value.startsWith(\"section\"))\n        return <Hash className=\"w-4 h-4 text-orange-600\" />;\n      return <Tag className=\"w-4 h-4 text-gray-600\" />;\n    }\n    return null;\n  };\n\n  return (\n    <li\n      className={`relative cursor-pointer select-none py-2 px-3 ${\n        selected ? \"bg-blue-50 text-blue-900\" : \"text-gray-900\"\n      } hover:bg-gray-50`}\n      {...props}\n      ref={ref}\n    >\n      <div className=\"flex items-center gap-3\">\n        {getIcon()}\n        <div className=\"flex-1 min-w-0\">\n          <div className=\"font-medium truncate\">{item.value}</div>\n          {item.data?.email && (\n            <div className=\"text-sm text-gray-500 truncate\">\n              {item.data.email}\n            </div>\n          )}\n          {item.data?.description && (\n            <div className=\"text-sm text-gray-500 truncate\">\n              {item.data.description}\n            </div>\n          )}\n        </div>\n      </div>\n    </li>\n  );\n});\nCustomMenuItem.displayName = \"BeautifulMentionsCustomMenuItem\";\n\nfunction ContentExtractor({\n  onContentChange,\n  onEditorStateChange,\n  initialContent,\n  initialEditorState,\n}: {\n  onContentChange: (content: string) => void;\n  onEditorStateChange: (editorState: string) => void;\n  initialContent?: string;\n  initialEditorState?: string;\n}) {\n  const [editor] = useLexicalComposerContext();\n\n  useEffect(() => {\n    if (initialEditorState && initialEditorState.trim()) {\n      editor.update(() => {\n        try {\n          const editorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(editorState);\n        } catch (error) {\n          debug.error(\"Failed to parse editor state:\", error);\n          if (initialContent && initialContent.trim()) {\n            const root = $getRoot();\n            root.clear();\n            const paragraph = $createParagraphNode();\n            const textNode = $createTextNode(initialContent);\n            paragraph.append(textNode);\n            root.append(paragraph);\n          }\n        }\n      });\n    } else if (initialContent && initialContent.trim()) {\n      editor.update(() => {\n        const root = $getRoot();\n        root.clear();\n        const paragraph = $createParagraphNode();\n        const textNode = $createTextNode(initialContent);\n        paragraph.append(textNode);\n        root.append(paragraph);\n      });\n    }\n  }, [editor, initialContent, initialEditorState]);\n\n  useEffect(() => {\n    const removeListener = editor.registerUpdateListener(({ editorState }) => {\n      editorState.read(() => {\n        const root = $getRoot();\n        const textContent = root.getTextContent();\n        onContentChange(textContent);\n      });\n\n      const editorStateJSON = JSON.stringify(editorState.toJSON());\n      onEditorStateChange(editorStateJSON);\n    });\n\n    return removeListener;\n  }, [editor, onContentChange, onEditorStateChange]);\n\n  return null;\n}\n\ninterface LexicalCommentComposerProps {\n  variant?: CommentVariant;\n  placeholder?: string;\n  onSubmit?: (\n    content: string,\n    editorState: string,\n    mentions: MentionUser[],\n    tags: MentionTag[]\n  ) => void;\n  className?: string;\n  initialContent?: string;\n  initialEditorState?: string;\n}\n\nexport function LexicalCommentComposer({\n  variant = \"card\",\n  placeholder,\n  onSubmit,\n  className = \"\",\n  initialContent = \"\",\n  initialEditorState = \"\",\n}: LexicalCommentComposerProps) {\n  const [currentContent, setCurrentContent] = useState(\"\");\n  const [currentEditorState, setCurrentEditorState] = useState(\"\");\n  const [showTooltip, setShowTooltip] = useState(false);\n  const submitButtonRef = useRef<HTMLButtonElement>(null);\n  const {\n    mentionItems,\n    loading: mentionLoading,\n    error: mentionError,\n  } = useMentions();\n  const { config } = useComments();\n\n  const effectiveVariant = variant || config.variant || \"default\";\n  const effectivePlaceholder =\n    placeholder || config.placeholder || \"Add a comment...\";\n  const features = config.editorFeatures || {};\n\n  const initialConfig = {\n    namespace: \"CommentEditor\",\n    theme: lexicalTheme,\n    nodes: lexicalNodes,\n    onError: (error: Error) => {\n      debug.error(\"Lexical error:\", error);\n    },\n  };\n\n  const handleSubmit = () => {\n    if (onSubmit && currentContent.trim()) {\n      onSubmit(currentContent.trim(), currentEditorState, [], []);\n\n      if (!initialContent && !initialEditorState) {\n        setCurrentContent(\"\");\n        setCurrentEditorState(\"\");\n      }\n    }\n  };\n\n  const buttonConfig = getButtonConfig(effectiveVariant);\n\n  return (\n    <div\n      className={`relative ${getContainerStyles(\n        effectiveVariant\n      )} ${className}`}\n    >\n      <LexicalComposer initialConfig={initialConfig}>\n        <div className=\"relative\">\n          <RichTextPlugin\n            contentEditable={\n              <ContentEditable\n                className={getContentEditableStyles(effectiveVariant)}\n                aria-placeholder={effectivePlaceholder}\n                placeholder={\n                  <div\n                    className={`absolute ${getPlaceholderPosition(\n                      effectiveVariant\n                    )} text-gray-400 pointer-events-none select-none`}\n                  >\n                    {effectivePlaceholder}\n                  </div>\n                }\n              />\n            }\n            placeholder={null}\n            ErrorBoundary={LexicalErrorBoundary}\n          />\n          <HistoryPlugin />\n          {features.lists !== false && <ListPlugin />}\n          {features.checkLists !== false && <CheckListPlugin />}\n          {features.mentions !== false && !mentionLoading && !mentionError && (\n            <BeautifulMentionsPlugin\n              items={mentionItems}\n              menuComponent={CustomMenu}\n              menuItemComponent={CustomMenuItem}\n            />\n          )}\n          <ContentExtractor\n            onContentChange={setCurrentContent}\n            onEditorStateChange={setCurrentEditorState}\n            initialContent={initialContent}\n            initialEditorState={initialEditorState}\n          />\n        </div>\n        {effectiveVariant !== \"inline\" && (\n          <div className=\"flex items-center justify-between mt-3 pt-3 border-t border-gray-100\">\n            <TooltipProvider>\n              <Tooltip\n                open={showTooltip}\n                onOpenChange={setShowTooltip}\n              >\n                <TooltipTrigger asChild>\n                  <Button\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    className=\"h-7 w-7 p-1 text-gray-500 hover:text-gray-700\"\n                    onTouchStart={() => setShowTooltip(true)}\n                    onTouchEnd={(e) => {\n                      e.preventDefault();\n                      setTimeout(() => setShowTooltip(false), 3000);\n                    }}\n                    onClick={() => setShowTooltip(!showTooltip)}\n                  >\n                    <HelpCircle className=\"w-4 h-4\" />\n                  </Button>\n                </TooltipTrigger>\n                <TooltipContent\n                  side=\"top\"\n                  align=\"start\"\n                  className=\"max-w-xs\"\n                >\n                  <div className=\"text-sm\">\n                    <p className=\"font-medium mb-2\">Start typing...</p>\n                    <ul className=\"space-y-1 text-xs\">\n                      {features.mentions !== false && (\n                        <>\n                          <li>• @ to mention users</li>\n                          <li>• # to reference resources</li>\n                        </>\n                      )}\n                      {features.lists !== false && (\n                        <>\n                          <li>• - for bullet lists</li>\n                          <li>• 1. for numbered lists</li>\n                        </>\n                      )}\n                      {features.autoLink !== false && (\n                        <li>• URLs will auto-link</li>\n                      )}\n                      {features.emoji !== false && <li>• : for emojis</li>}\n                    </ul>\n                    {mentionLoading && (\n                      <p className=\"text-xs text-amber-600 mt-2\">\n                        Loading mentions...\n                      </p>\n                    )}\n                    {mentionError && (\n                      <p className=\"text-xs text-red-600 mt-2\">\n                        Mention loading failed\n                      </p>\n                    )}\n                  </div>\n                </TooltipContent>\n              </Tooltip>\n            </TooltipProvider>\n            <Button\n              ref={submitButtonRef}\n              onClick={handleSubmit}\n              size={buttonConfig.size}\n              className={`flex items-center gap-2 ${\n                buttonConfig.className || \"\"\n              }`}\n              disabled={!currentContent.trim()}\n            >\n              {buttonConfig.showIcon && <Send className=\"w-4 h-4\" />}\n              {buttonConfig.showText && buttonConfig.text}\n            </Button>\n          </div>\n        )}\n        {features.autoList !== false && <AutoListPlugin />}\n        {features.autoLink !== false && <AutoLinkPlugin matchers={MATCHERS} />}\n        {features.emoji !== false && <EmojiPlugin />}\n        <KeyboardShortcutPlugin onSubmit={handleSubmit} />\n        <FocusManagementPlugin submitButtonRef={submitButtonRef} />\n      </LexicalComposer>\n    </div>\n  );\n}\n\nexport default LexicalCommentComposer;\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/lexical/lexical-read-only-renderer.tsx",
      "content": "\"use client\"\n\nimport { useEffect } from \"react\"\nimport { debug } from \"@/lib/comments/utils/debug\"\nimport { $createParagraphNode, $createTextNode, $getRoot } from \"lexical\"\nimport { LexicalComposer } from \"@lexical/react/LexicalComposer\"\nimport { RichTextPlugin } from \"@lexical/react/LexicalRichTextPlugin\"\nimport { ContentEditable } from \"@lexical/react/LexicalContentEditable\"\nimport { HistoryPlugin } from \"@lexical/react/LexicalHistoryPlugin\"\nimport { LexicalErrorBoundary } from \"@lexical/react/LexicalErrorBoundary\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport { ListPlugin } from \"@lexical/react/LexicalListPlugin\"\nimport { CheckListPlugin } from \"@lexical/react/LexicalCheckListPlugin\"\nimport { BeautifulMentionsPlugin } from \"lexical-beautiful-mentions\"\nimport { lexicalReadOnlyTheme, lexicalNodes, mentionItems, validateUrl } from \"./config/lexical-config\"\n\nexport { validateUrl }\n\ninterface LexicalReadOnlyRendererProps {\n  editorState?: string\n  content: string\n  className?: string\n}\n\nfunction EditorStateLoader({ editorState, content }: { editorState?: string; content: string }) {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    if (editorState) {\n      try {\n        const parsedState = JSON.parse(editorState)\n        editor.update(() => {\n          const newEditorState = editor.parseEditorState(parsedState)\n          editor.setEditorState(newEditorState)\n        })\n      } catch (error) {\n        debug.error(\"Failed to parse editor state:\", error)\n        editor.update(() => {\n          const root = $getRoot()\n          root.clear()\n          const paragraph = $createParagraphNode()\n          paragraph.append($createTextNode(content))\n          root.append(paragraph)\n        })\n      }\n    } else {\n      editor.update(() => {\n        const root = $getRoot()\n        root.clear()\n        const paragraph = $createParagraphNode()\n        paragraph.append($createTextNode(content))\n        root.append(paragraph)\n      })\n    }\n  }, [editor, editorState, content])\n\n  return null\n}\n\nexport function LexicalReadOnlyRenderer({ editorState, content, className = \"\" }: LexicalReadOnlyRendererProps) {\n  const initialConfig = {\n    namespace: \"ReadOnlyRenderer\",\n    editable: false,\n    theme: lexicalReadOnlyTheme,\n    nodes: lexicalNodes,\n    onError: (error: Error) => {\n      debug.error(\"Lexical read-only renderer error:\", error)\n    },\n  }\n\n  return (\n    <div className={`lexical-read-only ${className}`}>\n      <LexicalComposer initialConfig={initialConfig}>\n        <RichTextPlugin\n          contentEditable={\n            <ContentEditable className=\"lexical-content-editable outline-none resize-none overflow-hidden\" />\n          }\n          placeholder={null}\n          ErrorBoundary={LexicalErrorBoundary}\n        />\n        <HistoryPlugin />\n        <ListPlugin />\n        <CheckListPlugin />\n        <BeautifulMentionsPlugin items={mentionItems} menuComponent={() => null} menuItemComponent={() => null} />\n        <EditorStateLoader editorState={editorState} content={content} />\n      </LexicalComposer>\n    </div>\n  )\n}\n\nexport default LexicalReadOnlyRenderer\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/lexical/mention-component.tsx",
      "content": "import { forwardRef } from \"react\"\nimport type { BeautifulMentionComponentProps } from \"lexical-beautiful-mentions\"\nimport Link from \"next/link\"\nimport { ExternalLink } from \"lucide-react\"\nimport { getIcon, getStyles, generateResourceUrl } from \"./utils/mention-utils\"\n\nexport const CustomMentionComponent = forwardRef<HTMLSpanElement, BeautifulMentionComponentProps>(\n  ({ trigger, value, data, ...other }, ref) => {\n    return (\n      <span\n        {...other}\n        ref={ref}\n        className={getStyles(trigger)}\n        title={data?.email || data?.description || `${trigger}${value}`}\n      >\n        {getIcon(trigger, value)}\n        <span>{value}</span>\n        {trigger === \"#\" &&\n          (value.startsWith(\"question\") || value.startsWith(\"rule\") || value.startsWith(\"section\")) && (\n            <Link\n              href={generateResourceUrl(value)}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n              className=\"inline-flex items-center\"\n            >\n              <ExternalLink className=\"w-3 h-3 opacity-60 hover:opacity-100 transition-opacity\" />\n            </Link>\n          )}\n      </span>\n    )\n  },\n)\n\nCustomMentionComponent.displayName = \"CustomMentionComponent\"\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/lexical/plugins/auto-list-plugin.tsx",
      "content": "\"use client\"\n\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport { debug } from \"@/lib/comments/utils/debug\"\nimport { useEffect } from \"react\"\nimport { INSERT_UNORDERED_LIST_COMMAND, INSERT_ORDERED_LIST_COMMAND } from \"@lexical/list\"\nimport { $getSelection, $isRangeSelection, KEY_SPACE_COMMAND, COMMAND_PRIORITY_LOW } from \"lexical\"\n\nexport function AutoListPlugin(): null {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    debug.log(\"AutoListPlugin initialized\")\n\n    return editor.registerCommand(\n      KEY_SPACE_COMMAND,\n      () => {\n        debug.log(\"AutoListPlugin: Space key pressed\")\n\n        const selection = $getSelection()\n        debug.log(\"AutoListPlugin: Selection:\", selection)\n\n        if (!$isRangeSelection(selection)) {\n          debug.log(\"AutoListPlugin: Not a range selection, returning false\")\n          return false\n        }\n\n        const anchorNode = selection.anchor.getNode()\n        const element = anchorNode.getTopLevelElementOrThrow()\n        debug.log(\"AutoListPlugin: Element type:\", element.getType())\n\n        if (element.getType() !== \"paragraph\") {\n          debug.log(\"AutoListPlugin: Not a paragraph, returning false\")\n          return false\n        }\n\n        const textContent = element.getTextContent()\n        debug.log(\"AutoListPlugin: Text content:\", JSON.stringify(textContent))\n\n        // Check for bullet list pattern: exactly \"-\"\n        if (textContent === \"-\") {\n          debug.log(\"AutoListPlugin: Bullet list pattern detected, creating unordered list\")\n          editor.update(() => {\n            // Clear the dash and dispatch command\n            element.clear()\n            editor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND, undefined)\n          })\n          return true\n        }\n\n        // Check for numbered list pattern: exactly \"1.\", \"2.\", etc.\n        const numberedMatch = textContent.match(/^\\d+\\.$/)\n        if (numberedMatch) {\n          debug.log(\"AutoListPlugin: Numbered list pattern detected:\", textContent)\n          editor.update(() => {\n            // Clear the numbered prefix and dispatch command\n            element.clear()\n            editor.dispatchCommand(INSERT_ORDERED_LIST_COMMAND, undefined)\n          })\n          return true\n        }\n\n        debug.log(\"AutoListPlugin: No list pattern matched, returning false\")\n        return false\n      },\n      COMMAND_PRIORITY_LOW,\n    )\n  }, [editor])\n\n  return null\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/lexical/plugins/emoji-plugin.tsx",
      "content": "\"use client\";\n\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport { useEffect, useState, useRef, useCallback, useMemo } from \"react\";\nimport {\n  $getSelection,\n  $isRangeSelection,\n  type TextNode,\n  COMMAND_PRIORITY_LOW,\n  KEY_DOWN_COMMAND,\n} from \"lexical\";\nimport data from \"@emoji-mart/data\";\nimport { init, SearchIndex } from \"emoji-mart\";\nimport { debug } from \"@/lib/comments/utils/debug\";\n\n// Initialize emoji-mart data with proper configuration\nlet emojiMartInitialized = false;\n\nconst initializeEmojiMart = () => {\n  if (!emojiMartInitialized) {\n    try {\n      init({ data });\n      emojiMartInitialized = true;\n      debug.log(\"EmojiMart initialized successfully\");\n    } catch (error) {\n      debug.error(\"EmojiMart initialization failed:\", error);\n    }\n  }\n};\n\ninterface EmojiPluginProps {\n  className?: string;\n}\n\ninterface EmojiResult {\n  id: string;\n  name: string;\n  native: string;\n  keywords: string[];\n}\n\nexport function EmojiPlugin({ className = \"\" }: EmojiPluginProps) {\n  const [editor] = useLexicalComposerContext();\n  const [showResults, setShowResults] = useState(false);\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [emojiResults, setEmojiResults] = useState<EmojiResult[]>([]);\n  const [selectedIndex, setSelectedIndex] = useState(0);\n  const [resultsPosition, setResultsPosition] = useState({ top: 0, left: 0 });\n  const [triggerNode, setTriggerNode] = useState<TextNode | null>(null);\n  const [triggerOffset, setTriggerOffset] = useState<number>(0);\n  const resultsRef = useRef<HTMLDivElement>(null);\n\n  const searchEmojis = useMemo(\n    () => async (query: string) => {\n      if (!query.trim()) {\n        setEmojiResults([]);\n        return;\n      }\n\n      // Ensure emoji-mart is initialized\n      initializeEmojiMart();\n\n      try {\n        const results = await SearchIndex.search(query);\n        debug.log(\"Raw emoji search results:\", results?.slice(0, 2));\n        \n        if (!results || results.length === 0) {\n          setEmojiResults([]);\n          return;\n        }\n        \n        const emojiResults = results.slice(0, 8).map((emoji: any) => {\n          // Handle different possible data structures from emoji-mart\n          let native = emoji.native;\n          \n          // Fallback methods to get the native emoji\n          if (!native && emoji.skins?.[0]?.native) {\n            native = emoji.skins[0].native;\n          } else if (!native && emoji.unified) {\n            try {\n              native = String.fromCodePoint(...emoji.unified.split('-').map((u: string) => parseInt(u, 16)));\n            } catch (e) {\n              debug.log(\"Failed to convert unified to native:\", emoji.unified, e);\n              native = '❓';\n            }\n          } else if (!native) {\n            native = '❓';\n          }\n          \n          return {\n            id: emoji.id,\n            name: emoji.name || emoji.id,\n            native: native,\n            keywords: emoji.keywords || [],\n          };\n        });\n        \n        debug.log(\"Processed emoji results:\", emojiResults.slice(0, 2));\n        setEmojiResults(emojiResults);\n        setSelectedIndex(0);\n      } catch (error) {\n        debug.log(\"Emoji search error:\", error);\n        setEmojiResults([]);\n      }\n    },\n    []\n  );\n\n  const updateResultsPosition = useCallback(() => {\n    try {\n      const domSelection = window.getSelection();\n      if (domSelection && domSelection.rangeCount > 0) {\n        const range = domSelection.getRangeAt(0);\n        const rect = range.getBoundingClientRect();\n\n        // Find the closest editor container (handles reply/edit contexts)\n        const editorElement = editor.getRootElement();\n        let containerElement = editorElement;\n\n        // Look for the closest positioned container (for reply/edit modals)\n        let parent = editorElement?.parentElement;\n        while (parent && parent !== document.body) {\n          const style = window.getComputedStyle(parent);\n          if (\n            style.position === \"relative\" ||\n            style.position === \"absolute\" ||\n            style.position === \"fixed\"\n          ) {\n            containerElement = parent;\n            break;\n          }\n          parent = parent.parentElement;\n        }\n\n        const containerRect = containerElement?.getBoundingClientRect();\n\n        if (containerRect) {\n          // Position relative to the container for better accuracy in different contexts\n          setResultsPosition({\n            top: rect.bottom - containerRect.top + 5,\n            left: Math.max(rect.left - containerRect.left, 0),\n          });\n          debug.log(\"EmojiPlugin: Position updated\", {\n            top: rect.bottom - containerRect.top + 5,\n            left: Math.max(rect.left - containerRect.left, 0),\n          });\n        } else {\n          // Fallback to viewport positioning\n          setResultsPosition({\n            top: rect.bottom + window.scrollY + 5,\n            left: rect.left + window.scrollX,\n          });\n        }\n      }\n    } catch (error) {\n      debug.log(\"Position calculation error:\", error);\n    }\n  }, [editor]);\n\n  const handleEmojiSelect = (emoji: EmojiResult) => {\n    debug.log(\"EmojiPlugin: Emoji selected:\", emoji);\n\n    if (!emoji.native) {\n      debug.error(\"EmojiPlugin: No native emoji found:\", emoji);\n      setShowResults(false);\n      setSearchQuery(\"\");\n      setTriggerNode(null);\n      return;\n    }\n\n    editor.update(() => {\n      if (triggerNode && typeof triggerOffset === \"number\") {\n        try {\n          const textContent = triggerNode.getTextContent();\n          const selection = $getSelection();\n\n          if ($isRangeSelection(selection) && selection.isCollapsed()) {\n            const currentOffset = selection.anchor.offset;\n            const beforeTrigger = textContent.substring(0, triggerOffset);\n            const afterSearch = textContent.substring(currentOffset);\n            const newText = beforeTrigger + emoji.native + afterSearch;\n\n            triggerNode.setTextContent(newText);\n\n            // Move cursor after the emoji\n            const newOffset = triggerOffset + emoji.native.length;\n            selection.anchor.set(triggerNode.getKey(), newOffset, \"text\");\n            selection.focus.set(triggerNode.getKey(), newOffset, \"text\");\n\n            debug.log(\"EmojiPlugin: Emoji inserted successfully\");\n          }\n        } catch (error) {\n          debug.log(\"Emoji insertion error:\", error);\n        }\n      }\n    });\n\n    setShowResults(false);\n    setSearchQuery(\"\");\n    setTriggerNode(null);\n    setTimeout(() => editor.focus(), 10);\n  };\n\n  const keyDownHandler = useMemo(\n    () => (event: KeyboardEvent) => {\n      if (showResults) {\n        // Handle navigation within results\n        if (event.key === \"ArrowDown\") {\n          event.preventDefault();\n          setSelectedIndex((prev) =>\n            Math.min(prev + 1, emojiResults.length - 1)\n          );\n          return true;\n        }\n        if (event.key === \"ArrowUp\") {\n          event.preventDefault();\n          setSelectedIndex((prev) => Math.max(prev - 1, 0));\n          return true;\n        }\n        if (event.key === \"Enter\") {\n          event.preventDefault();\n          if (emojiResults[selectedIndex]) {\n            handleEmojiSelect(emojiResults[selectedIndex]);\n          }\n          return true;\n        }\n        if (event.key === \"Escape\") {\n          setShowResults(false);\n          setSearchQuery(\"\");\n          setTriggerNode(null);\n          return true;\n        }\n        if (event.key === \"Backspace\") {\n          setTimeout(() => {\n            try {\n              editor.getEditorState().read(() => {\n                if (!triggerNode) return;\n\n                const textContent = triggerNode.getTextContent();\n                const colonIndex = triggerOffset;\n                const selection = $getSelection();\n\n                if ($isRangeSelection(selection) && selection.isCollapsed()) {\n                  const currentOffset = selection.anchor.offset;\n\n                  // If cursor is at or before the colon, close the picker\n                  if (currentOffset <= colonIndex + 1) {\n                    setShowResults(false);\n                    setSearchQuery(\"\");\n                    setTriggerNode(null);\n                    return;\n                  }\n\n                  const searchText = textContent.substring(\n                    colonIndex + 1,\n                    currentOffset\n                  );\n                  setSearchQuery(searchText);\n                  searchEmojis(searchText);\n                }\n              });\n            } catch (error) {\n              debug.log(\"Backspace handling error:\", error);\n              // Close picker on error to prevent stuck state\n              setShowResults(false);\n              setSearchQuery(\"\");\n              setTriggerNode(null);\n            }\n          }, 10);\n          return false; // Allow backspace to proceed normally\n        }\n      }\n\n      if (event.key === \":\") {\n        debug.log(\"EmojiPlugin: Colon detected, starting search mode...\");\n\n        setTimeout(() => {\n          try {\n            editor.getEditorState().read(() => {\n              const selection = $getSelection();\n              if (!$isRangeSelection(selection) || !selection.isCollapsed())\n                return;\n\n              const anchorNode = selection.anchor.getNode();\n              const anchorOffset = selection.anchor.offset;\n\n              if (anchorNode.getType() === \"text\" && anchorOffset > 0) {\n                const textNode = anchorNode as TextNode;\n                const textContent = textNode.getTextContent();\n                const charBeforeCursor = textContent[anchorOffset - 1];\n\n                if (charBeforeCursor === \":\") {\n                  debug.log(\"EmojiPlugin: Starting emoji search\");\n                  setTriggerNode(textNode);\n                  setTriggerOffset(anchorOffset - 1);\n                  setSearchQuery(\"\");\n                  setShowResults(true);\n                  updateResultsPosition();\n                }\n              }\n            });\n          } catch (error) {\n            debug.log(\"Colon detection error:\", error);\n          }\n        }, 10);\n      }\n\n      if (\n        showResults &&\n        event.key.length === 1 &&\n        !event.ctrlKey &&\n        !event.metaKey &&\n        event.key !== \":\"\n      ) {\n        setTimeout(() => {\n          try {\n            editor.getEditorState().read(() => {\n              if (!triggerNode) return;\n\n              const textContent = triggerNode.getTextContent();\n              const colonIndex = triggerOffset;\n              const selection = $getSelection();\n\n              if ($isRangeSelection(selection) && selection.isCollapsed()) {\n                const currentOffset = selection.anchor.offset;\n                const searchText = textContent.substring(\n                  colonIndex + 1,\n                  currentOffset\n                );\n                debug.log(\"EmojiPlugin: Search query updated:\", searchText);\n                setSearchQuery(searchText);\n                searchEmojis(searchText);\n              }\n            });\n          } catch (error) {\n            debug.log(\"Search update error:\", error);\n            // Close picker on error to prevent stuck state\n            setShowResults(false);\n            setSearchQuery(\"\");\n            setTriggerNode(null);\n          }\n        }, 10);\n      }\n\n      return false;\n    },\n    [\n      showResults,\n      emojiResults,\n      selectedIndex,\n      triggerNode,\n      triggerOffset,\n      searchEmojis,\n      updateResultsPosition,\n      editor,\n      handleEmojiSelect,\n    ]\n  );\n\n  useEffect(() => {\n    debug.log(\"EmojiPlugin initialized\");\n    \n    // Initialize emoji-mart when component mounts\n    initializeEmojiMart();\n\n    const removeKeyListener = editor.registerCommand(\n      KEY_DOWN_COMMAND,\n      keyDownHandler,\n      COMMAND_PRIORITY_LOW\n    );\n\n    return removeKeyListener;\n  }, [editor, keyDownHandler]);\n\n  // Close results when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (\n        resultsRef.current &&\n        !resultsRef.current.contains(event.target as Node)\n      ) {\n        setShowResults(false);\n        setSearchQuery(\"\");\n        setTriggerNode(null);\n      }\n    };\n\n    if (showResults) {\n      document.addEventListener(\"mousedown\", handleClickOutside);\n      return () =>\n        document.removeEventListener(\"mousedown\", handleClickOutside);\n    }\n  }, [showResults]);\n\n  if (!showResults || emojiResults.length === 0) {\n    return null;\n  }\n\n  return (\n    <div\n      ref={resultsRef}\n      className={`absolute z-50 ${className}`}\n      style={{\n        top: resultsPosition.top,\n        left: resultsPosition.left,\n      }}\n    >\n      <div className=\"bg-white rounded-lg shadow-lg border border-gray-200 overflow-hidden min-w-[200px] max-w-[300px]\">\n        <div className=\"p-2 text-xs text-gray-500 border-b\">\n          {searchQuery\n            ? `Search: \"${searchQuery}\"`\n            : \"Type to search emojis...\"}\n        </div>\n        <div className=\"max-h-[200px] overflow-y-auto\">\n          {emojiResults.map((emoji, index) => (\n            <div\n              key={emoji.id}\n              className={`flex items-center gap-2 px-3 py-2 cursor-pointer hover:bg-gray-50 ${\n                index === selectedIndex\n                  ? \"bg-blue-50 border-l-2 border-blue-500\"\n                  : \"\"\n              }`}\n              onClick={() => handleEmojiSelect(emoji)}\n            >\n              <span className=\"text-lg\">{emoji.native || '❓'}</span>\n              <div className=\"flex-1 min-w-0\">\n                <div className=\"text-sm font-medium text-gray-900 truncate\">\n                  {emoji.name}\n                </div>\n                {emoji.keywords.length > 0 && (\n                  <div className=\"text-xs text-gray-500 truncate\">\n                    {emoji.keywords.slice(0, 3).join(\", \")}\n                  </div>\n                )}\n              </div>\n            </div>\n          ))}\n        </div>\n        <div className=\"p-2 text-xs text-gray-400 border-t\">\n          ↑↓ navigate • Enter select • Esc cancel\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default EmojiPlugin;"
    },
    {
      "type": "registry:component",
      "path": "lib/components/lexical/plugins/focus-management-plugin.tsx",
      "content": "\"use client\"\n\nimport { useEffect } from \"react\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport { \n  KEY_TAB_COMMAND,\n  COMMAND_PRIORITY_HIGH,\n} from \"lexical\"\n\ninterface FocusManagementPluginProps {\n  submitButtonRef: React.RefObject<HTMLButtonElement | null>\n}\n\nexport function FocusManagementPlugin({ submitButtonRef }: FocusManagementPluginProps) {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    return editor.registerCommand(\n      KEY_TAB_COMMAND,\n      (event) => {\n        if (!event) return false\n        \n        const { shiftKey } = event as KeyboardEvent\n        \n        // If Tab (without Shift) is pressed, focus the submit button\n        if (!shiftKey) {\n          event.preventDefault()\n          submitButtonRef.current?.focus()\n          return true\n        }\n        \n        // Let Shift+Tab work normally\n        return false\n      },\n      COMMAND_PRIORITY_HIGH\n    )\n  }, [editor, submitButtonRef])\n\n  return null\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/lexical/plugins/keyboard-shortcut-plugin.tsx",
      "content": "\"use client\"\n\nimport { useEffect } from \"react\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport { \n  KEY_ENTER_COMMAND,\n  COMMAND_PRIORITY_NORMAL,\n} from \"lexical\"\n\ninterface KeyboardShortcutPluginProps {\n  onSubmit: () => void\n}\n\nexport function KeyboardShortcutPlugin({ onSubmit }: KeyboardShortcutPluginProps) {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    return editor.registerCommand(\n      KEY_ENTER_COMMAND,\n      (event) => {\n        if (!event) return false\n        \n        const { ctrlKey, metaKey } = event as KeyboardEvent\n        \n        // Check for Cmd+Enter (macOS) or Ctrl+Enter (Windows/Linux)\n        if (ctrlKey || metaKey) {\n          event.preventDefault()\n          onSubmit()\n          return true\n        }\n        \n        return false\n      },\n      COMMAND_PRIORITY_NORMAL\n    )\n  }, [editor, onSubmit])\n\n  return null\n}\n"
    },
    {
      "type": "registry:component",
      "path": "lib/components/lexical/utils/mention-utils.tsx",
      "content": "import { User, Hash, FileText, BookOpen, Tag } from \"lucide-react\"\n\nexport const getIcon = (trigger: string, value: string) => {\n  if (trigger === \"@\") return <User className=\"w-3 h-3\" />\n  if (trigger === \"#\") {\n    if (value.startsWith(\"question\")) return <FileText className=\"w-3 h-3\" />\n    if (value.startsWith(\"rule\")) return <BookOpen className=\"w-3 h-3\" />\n    if (value.startsWith(\"section\")) return <Hash className=\"w-3 h-3\" />\n    return <Tag className=\"w-3 h-3\" />\n  }\n  return null\n}\n\nexport const getStyles = (trigger: string) => {\n  if (trigger === \"@\") {\n    return \"inline-flex items-center gap-1 px-2 py-0.5 bg-blue-100 text-blue-800 rounded-md text-sm font-medium hover:bg-blue-200 transition-colors\"\n  }\n  return \"inline-flex items-center gap-1 px-2 py-0.5 bg-green-100 text-green-800 rounded-md text-sm font-medium hover:bg-green-200 transition-colors\"\n}\n\nexport const generateResourceUrl = (value: string): string => {\n  if (value.startsWith(\"question\")) {\n    return `/audit/questions/${value}`\n  } else if (value.startsWith(\"rule\")) {\n    return `/audit/rules/${value}`\n  } else if (value.startsWith(\"section\")) {\n    return `/audit/sections/${value}`\n  }\n  return `/audit/resources/${value}`\n}\n"
    },
    {
      "type": "registry:lib",
      "path": "lib/components/lexical/utils/style-utils.ts",
      "content": "import { CommentVariant } from \"@/lib/comments/types/comments\";\n\nexport const getContainerStyles = (variant: CommentVariant) => {\n  switch (variant) {\n    case \"compact\":\n      return \"border border-gray-200 rounded-lg p-2 bg-white\";\n    case \"inline\":\n      return \"border-b border-gray-200 pb-2\";\n    case \"bubble\":\n      return \"border border-blue-200 rounded-2xl p-3 bg-blue-50/50\";\n    case \"timeline\":\n      return \"border border-blue-200 rounded-xl p-4 bg-gradient-to-br from-blue-50 to-white shadow-sm hover:shadow-md transition-shadow duration-200\";\n    case \"social\":\n      return \"border border-gray-200 rounded-xl p-4 bg-white shadow-sm hover:shadow-md transition-shadow\";\n    case \"professional\":\n      return \"border border-gray-300 rounded-lg p-4 bg-white shadow-sm\";\n    case \"clean\":\n      return \"border-b border-gray-100 pb-4 mb-4\";\n    case \"github\":\n      return \"border border-gray-300 rounded-md p-3 bg-gray-50\";\n    case \"email\":\n      return \"border border-gray-200 rounded-lg p-4 bg-white\";\n    case \"notion\":\n      return \"border border-gray-200 rounded-lg p-4 bg-white hover:bg-gray-50/50 transition-colors\";\n    case \"mobile\":\n      return \"border border-gray-200 rounded-lg p-4 bg-white shadow-sm\";\n    case \"thread\":\n      return \"border-l-2 border-gray-200 pl-4 py-2\";\n    case \"card\":\n      return \"border border-gray-200 rounded-lg p-4 bg-white shadow-sm\";\n    default:\n      return \"border border-gray-200 rounded-lg p-4 bg-white shadow-sm\";\n  }\n};\n\nexport const getContentEditableStyles = (variant: CommentVariant) => {\n  switch (variant) {\n    case \"compact\":\n      return \"min-h-[60px] p-2 text-sm focus:outline-none\";\n    case \"inline\":\n      return \"min-h-[32px] p-1 text-sm focus:outline-none\";\n    case \"bubble\":\n      return \"min-h-[80px] p-3 text-sm focus:outline-none rounded-xl\";\n    case \"timeline\":\n      return \"min-h-[90px] p-4 focus:outline-none focus:ring-2 focus:ring-blue-200 focus:ring-opacity-50 rounded-lg transition-all duration-200\";\n    case \"social\":\n      return \"min-h-[90px] p-3 focus:outline-none\";\n    case \"professional\":\n      return \"min-h-[100px] p-3 focus:outline-none font-medium\";\n    case \"clean\":\n      return \"min-h-[80px] p-2 focus:outline-none\";\n    case \"github\":\n      return \"min-h-[80px] p-2 text-sm focus:outline-none font-mono\";\n    case \"email\":\n      return \"min-h-[100px] p-3 focus:outline-none\";\n    case \"notion\":\n      return \"min-h-[90px] p-3 focus:outline-none\";\n    case \"mobile\":\n      return \"min-h-[100px] p-4 text-base focus:outline-none\";\n    case \"thread\":\n      return \"min-h-[70px] p-2 text-sm focus:outline-none\";\n    case \"card\":\n      return \"min-h-[100px] p-3 focus:outline-none\";\n    default:\n      return \"min-h-[100px] p-3 focus:outline-none\";\n  }\n};\n\nexport const getPlaceholderPosition = (variant: CommentVariant) => {\n  switch (variant) {\n    case \"inline\":\n      return \"top-1 left-1\"; // matches p-1 padding\n    case \"compact\":\n      return \"top-2 left-2\"; // matches p-2 padding\n    case \"bubble\":\n    case \"social\":\n    case \"professional\":\n    case \"email\":\n    case \"notion\":\n    case \"card\":\n      return \"top-3 left-3\"; // matches p-3 padding\n    case \"mobile\":\n      return \"top-4 left-4\"; // matches p-4 padding\n    case \"timeline\":\n    case \"github\":\n    case \"thread\":\n    case \"clean\":\n      return \"top-2 left-2\"; // matches p-2 padding\n    default:\n      return \"top-3 left-3\"; // default p-3 padding\n  }\n};\n\nexport const getButtonConfig = (variant: CommentVariant) => {\n  switch (variant) {\n    case \"compact\":\n      return {\n        size: \"sm\" as const,\n        showIcon: true,\n        showText: false,\n        text: \"\",\n        className: \"px-2\",\n      };\n    case \"mobile\":\n      return {\n        size: \"default\" as const,\n        showIcon: false,\n        showText: true,\n        text: \"Post Comment\",\n        className: \"px-6 flex-grow ml-1\",\n      };\n    case \"inline\":\n      return {\n        size: \"xs\" as const,\n        showIcon: true,\n        showText: false,\n        text: \"\",\n        className: \"px-1\",\n      };\n    case \"bubble\":\n      return {\n        size: \"sm\" as const,\n        showIcon: true,\n        showText: true,\n        text: \"Send\",\n        className: \"rounded-full\",\n      };\n    case \"timeline\":\n      return {\n        size: \"sm\" as const,\n        showIcon: true,\n        showText: true,\n        text: \"Add to Timeline\",\n        className:\n          \"bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white shadow-sm hover:shadow-md transition-all duration-200\",\n      };\n    case \"social\":\n      return {\n        size: \"default\" as const,\n        showIcon: true,\n        showText: true,\n        text: \"Share\",\n        className: \"bg-blue-600 hover:bg-blue-700\",\n      };\n    case \"professional\":\n      return {\n        size: \"default\" as const,\n        showIcon: true,\n        showText: true,\n        text: \"Submit\",\n        className: \"bg-gray-900 hover:bg-gray-800\",\n      };\n    case \"clean\":\n      return {\n        size: \"sm\" as const,\n        showIcon: false,\n        showText: true,\n        text: \"Post\",\n        className:\n          \"bg-transparent border border-gray-300 text-gray-700 hover:bg-gray-50\",\n      };\n    case \"github\":\n      return {\n        size: \"sm\" as const,\n        showIcon: true,\n        showText: true,\n        text: \"Comment\",\n        className: \"bg-green-600 hover:bg-green-700\",\n      };\n    case \"email\":\n      return {\n        size: \"default\" as const,\n        showIcon: true,\n        showText: true,\n        text: \"Send\",\n        className: \"bg-blue-600 hover:bg-blue-700\",\n      };\n    case \"notion\":\n      return {\n        size: \"sm\" as const,\n        showIcon: false,\n        showText: true,\n        text: \"Comment\",\n        className: \"bg-gray-800 hover:bg-gray-900\",\n      };\n    case \"thread\":\n      return {\n        size: \"xs\" as const,\n        showIcon: true,\n        showText: true,\n        text: \"Reply\",\n        className: \"px-1.5 py-0.5\",\n      };\n    case \"card\":\n      return {\n        size: \"default\" as const,\n        showIcon: true,\n        showText: true,\n        text: \"Post Comment\",\n        className: \"\",\n      };\n    default:\n      return {\n        size: \"default\" as const,\n        showIcon: true,\n        showText: true,\n        text: \"Post Comment\",\n        className: \"\",\n      };\n  }\n};\n"
    },
    {
      "type": "registry:lib",
      "path": "lib/contexts/comment-context.tsx",
      "content": "\"use client\";\n\nimport React, {\n    createContext,\n    useContext,\n    useReducer,\n    useEffect,\n    useCallback,\n    useMemo,\n} from \"react\";\nimport type {\n    Comment,\n    CommentThread,\n    User,\n    CommentReaction,\n} from \"@/lib/comments/types/comments\";\nimport type { CommentStorageAdapter } from \"@/lib/comments/adapters\";\nimport { LocalStorageAdapter } from \"@/lib/comments/adapters\";\nimport { generateId } from \"@/lib/comments/utils/generateId\";\nimport {\n    commentReducer,\n    initialCommentState,\n    type CommentState,\n} from \"@/lib/comments/reducers/comment-reducer\";\nimport {\n    CommentEventEmitter,\n    type CommentEventMap,\n    type CommentEventListener,\n} from \"@/lib/comments/comment-events\";\nimport {\n    useCommentConfig,\n    type CommentConfig,\n    createDebugLogger,\n} from \"@/lib/comments/hooks/use-comment-config\";\nimport { useCommentContextHooks } from \"@/lib/comments/hooks/use-comment-context-hooks\";\nimport { extractMentionsAndTags } from \"@/lib/comments/lexical-utils\";\nimport { setDebugMode } from \"@/lib/comments/utils/debug\";\nimport type {\n    CommentHooks,\n    CommentHookRegistry,\n    AddCommentHookData,\n    UpdateCommentHookData,\n    CommentHookData,\n} from \"@/lib/comments/types/comment-hooks\";\n\nconst commentEvents = new CommentEventEmitter();\n\n// Helper hook for subscribing to events in React components\nexport function useCommentEvent<T extends keyof CommentEventMap>(\n  event: T,\n  listener: CommentEventListener<T>\n): void {\n  React.useEffect(() => {\n    const unsubscribe = commentEvents.on(event, listener);\n    return unsubscribe;\n  }, [event, listener]);\n}\n\ninterface CommentContextType {\n  state: CommentState;\n  currentUser: User | null;\n  config: CommentConfig;\n  events: CommentEventEmitter;\n  hooks: CommentHookRegistry;\n\n  addComment: (\n    content: string,\n    editorState: string,\n    sourceId?: string,\n    sourceType?: string,\n    parentId?: string\n  ) => Promise<void>;\n  updateComment: (\n    commentId: string,\n    content: string,\n    editorState: string\n  ) => Promise<void>;\n  deleteComment: (commentId: string) => Promise<void>;\n  addReaction: (commentId: string, reactionType: string) => Promise<void>;\n  removeReaction: (commentId: string, reactionId: string) => Promise<void>;\n\n  // Data retrieval\n  getCommentThreads: (\n    sourceId?: string,\n    sourceType?: string\n  ) => Promise<CommentThread[]>;\n  getcommentsSource: (sourceId: string, sourceType?: string) => Comment[];\n  getRepliesForComment: (parentId: string) => Comment[];\n\n  refreshData: () => Promise<void>;\n\n  // Configuration management\n  updateConfig: (newConfig: Partial<CommentConfig>) => void;\n\n  clearAllStorage: () => Promise<void>;\n}\n\n// Create context\nconst CommentContext = createContext<CommentContextType | undefined>(undefined);\n\ninterface CommentProviderProps {\n  children: React.ReactNode;\n  currentUser?: User | null;\n  storageAdapter?: CommentStorageAdapter;\n  initialComments?: Comment[];\n  config?: CommentConfig;\n  hooks?: Partial<CommentHooks>;\n  hideToast?: boolean;\n}\n\nexport function CommentProvider({\n  children,\n  currentUser = null,\n  storageAdapter,\n  initialComments,\n  config,\n  hooks: initialHooks,\n  hideToast,\n}: CommentProviderProps) {\n  const [state, dispatch] = useReducer(commentReducer, {\n    ...initialCommentState,\n    comments: initialComments || [],\n  });\n  const { config: currentConfig, updateConfig } = useCommentConfig({\n    ...config,\n    hideToast,\n  });\n\n  const adapter = useMemo(\n    () => storageAdapter || new LocalStorageAdapter(),\n    [storageAdapter]\n  );\n\n  const { hookRegistry, createHookContext } = useCommentContextHooks({\n    initialHooks,\n    currentUser,\n    config: currentConfig,\n    state,\n    events: commentEvents,\n  });\n\n  // Create debug logger and set global debug mode\n  const debug = useMemo(() => {\n    setDebugMode(currentConfig.debug || false);\n    return createDebugLogger(currentConfig);\n  }, [currentConfig]);\n\n  useEffect(() => {\n    if (initialComments) {\n      debug.log(\"Using provided initial data, skipping loadData\");\n      commentEvents.emit(\"comments:loaded\", { comments: initialComments });\n      return;\n    }\n\n    const loadData = async () => {\n      dispatch({ type: \"SET_LOADING\", payload: true });\n      try {\n        const comments = await adapter.getComments();\n\n        if (!initialComments) {\n          dispatch({ type: \"LOAD_COMMENTS\", payload: comments });\n          commentEvents.emit(\"comments:loaded\", { comments });\n        }\n      } catch (error) {\n        // The `error` variable is a placeholder for the actual implementation.\n        if (error) {\n          // do nothing\n        }\n        const errorMessage = \"Failed to load comments\";\n        dispatch({ type: \"SET_ERROR\", payload: errorMessage });\n        commentEvents.emit(\"error\", { error: errorMessage, action: \"load\" });\n      }\n    };\n\n    loadData();\n  }, [adapter, initialComments]);\n\n  const addComment = useCallback(\n    async (\n      content: string,\n      editorState: string,\n      sourceId?: string,\n      sourceType?: string,\n      parentId?: string\n    ) => {\n      if (!currentUser) {\n        const errorMessage = \"User must be logged in to comment\";\n        dispatch({ type: \"SET_ERROR\", payload: errorMessage });\n        commentEvents.emit(\"error\", { error: errorMessage, action: \"add\" });\n        return;\n      }\n\n      try {\n        debug.log(\"Context addComment called with:\", {\n          content,\n          sourceId,\n          sourceType,\n          parentId,\n        });\n\n        let finalSourceId = sourceId;\n        let finalSourceType = sourceType;\n        let finalParentId = parentId;\n\n        if (parentId && !sourceId) {\n          const parentComment = state.comments.find((c) => c.id === parentId);\n          if (parentComment) {\n            finalSourceId = parentComment.sourceId;\n            finalSourceType = parentComment.sourceType;\n            finalParentId = parentComment.parentId || parentId;\n            debug.log(\n              \"Reply inheriting sourceId/sourceType from parent:\",\n              finalSourceId,\n              finalSourceType\n            );\n            debug.log(\n              \"Flat threading - using parent:\",\n              finalParentId\n            );\n          }\n        }\n\n        const { mentions, tags } = extractMentionsAndTags(editorState);\n        debug.log(\"Extracted mentions:\", mentions, \"tags:\", tags);\n\n        const hookData: AddCommentHookData = {\n          content,\n          editorState,\n          mentions,\n          tags,\n          sourceId: finalSourceId,\n          sourceType: finalSourceType,\n          parentId: finalParentId,\n          user: currentUser,\n        };\n\n        const processedData = await hookRegistry.executeHooks(\n          \"beforeAddComment\",\n          hookData,\n          createHookContext()\n        );\n\n        const newComment = await adapter.addLexicalComment(\n          processedData.content,\n          processedData.editorState,\n          processedData.user,\n          processedData.mentions,\n          processedData.tags,\n          processedData.sourceId,\n          processedData.sourceType,\n          processedData.parentId\n        );\n\n        debug.log(\"New comment created:\", newComment);\n\n        const commentHookData: CommentHookData = { comment: newComment };\n        const processedComment = await hookRegistry.executeHooks(\n          \"beforeSaveComment\",\n          commentHookData,\n          createHookContext()\n        );\n\n        const finalComment = { ...newComment, ...processedComment };\n\n        dispatch({ type: \"ADD_COMMENT\", payload: finalComment });\n        commentEvents.emit(\"comment:added\", {\n          comment: finalComment,\n          user: currentUser,\n        });\n\n        await hookRegistry.executeHooks(\n          \"afterAddComment\",\n          { comment: finalComment },\n          createHookContext()\n        );\n        await hookRegistry.executeHooks(\n          \"afterSaveComment\",\n          { comment: finalComment },\n          createHookContext()\n        );\n\n        debug.log(\"Comment added to state\");\n      } catch (error) {\n        // The `error` variable is a placeholder for the actual implementation.\n        if (error) {\n          // do nothing\n        }\n        debug.error(\"Error adding comment:\", error);\n        const errorMessage = \"Failed to add comment\";\n        dispatch({ type: \"SET_ERROR\", payload: errorMessage });\n        commentEvents.emit(\"error\", { error: errorMessage, action: \"add\" });\n      }\n    },\n    [currentUser, state.comments, adapter, hookRegistry, createHookContext, debug]\n  );\n\n  const updateComment = useCallback(\n    async (commentId: string, content: string, editorState: string) => {\n      if (!currentUser) return;\n\n      try {\n        debug.log(\"updateComment called with:\", {\n          commentId,\n          content,\n          editorState: editorState ? \"present\" : \"undefined\",\n        });\n\n        if (!editorState) {\n          debug.error(\n            \"ERROR: editorState is undefined in updateComment!\"\n          );\n          return;\n        }\n\n        const existingComment = state.comments.find((c) => c.id === commentId);\n        if (!existingComment) return;\n\n        const previousContent = existingComment.content || \"\";\n\n        const { mentions, tags } = extractMentionsAndTags(editorState);\n        debug.log(\n          \"Extracted mentions for update:\",\n          mentions,\n          \"tags:\",\n          tags\n        );\n\n        const hookData: UpdateCommentHookData = {\n          commentId,\n          content,\n          editorState,\n          mentions,\n          tags,\n          existingComment,\n        };\n\n        const processedData = await hookRegistry.executeHooks(\n          \"beforeUpdateComment\",\n          hookData,\n          createHookContext()\n        );\n\n        const updates = {\n          content: processedData.content,\n          editorState: processedData.editorState,\n          isEdited: true,\n          mentions: processedData.mentions,\n          tags: processedData.tags,\n        };\n\n        dispatch({\n          type: \"UPDATE_COMMENT\",\n          payload: { id: commentId, updates },\n        });\n\n        await adapter.updateCommentWithEditorState(\n          commentId,\n          processedData.content,\n          processedData.editorState,\n          processedData.mentions,\n          processedData.tags\n        );\n\n        const updatedComment = { ...existingComment, ...updates };\n\n        const commentHookData: CommentHookData = { comment: updatedComment };\n        const processedComment = await hookRegistry.executeHooks(\n          \"beforeSaveComment\",\n          commentHookData,\n          createHookContext()\n        );\n\n        const finalComment = { ...updatedComment, ...processedComment };\n\n        commentEvents.emit(\"comment:updated\", {\n          comment: finalComment,\n          previousContent,\n          user: currentUser,\n        });\n\n        await hookRegistry.executeHooks(\n          \"afterUpdateComment\",\n          { comment: finalComment },\n          createHookContext()\n        );\n        await hookRegistry.executeHooks(\n          \"afterSaveComment\",\n          { comment: finalComment },\n          createHookContext()\n        );\n\n        debug.log(\"Comment updated in storage successfully\");\n      } catch (error) {\n        // The `error` variable is a placeholder for the actual implementation.\n        if (error) {\n          // do nothing\n        }\n        debug.error(\"Error updating comment:\", error);\n        const errorMessage = \"Failed to update comment\";\n        dispatch({ type: \"SET_ERROR\", payload: errorMessage });\n        commentEvents.emit(\"error\", { error: errorMessage, action: \"update\" });\n      }\n    },\n    [adapter, currentUser, state.comments, hookRegistry, createHookContext, debug]\n  );\n\n  const deleteComment = useCallback(\n    async (commentId: string) => {\n      if (!currentUser) return;\n\n      try {\n        dispatch({ type: \"DELETE_COMMENT\", payload: commentId });\n\n        await adapter.deleteComment(commentId);\n\n        commentEvents.emit(\"comment:deleted\", { commentId, user: currentUser });\n      } catch (error) {\n        // The `error` variable is a placeholder for the actual implementation.\n        if (error) {\n          // do nothing\n        }\n        const errorMessage = \"Failed to delete comment\";\n        dispatch({ type: \"SET_ERROR\", payload: errorMessage });\n        commentEvents.emit(\"error\", { error: errorMessage, action: \"delete\" });\n      }\n    },\n    [adapter, currentUser]\n  );\n\n  const addReaction = useCallback(\n    async (commentId: string, reactionType: string) => {\n      if (!currentUser) return;\n\n      try {\n        const comment = state.comments.find((c) => c.id === commentId);\n        const existingReaction = comment?.reactions.find(\n          (r) => r.userId === currentUser.id && r.type === reactionType\n        );\n\n        if (existingReaction) {\n          dispatch({\n            type: \"REMOVE_REACTION\",\n            payload: { commentId, reactionId: existingReaction.id },\n          });\n          commentEvents.emit(\"reaction:removed\", {\n            commentId,\n            reactionId: existingReaction.id,\n            user: currentUser,\n          });\n        } else {\n          const newReaction: CommentReaction = {\n            id: generateId(),\n            userId: currentUser.id,\n            type: reactionType as CommentReaction['type'],\n            createdAt: new Date(),\n          };\n\n          dispatch({\n            type: \"ADD_REACTION\",\n            payload: { commentId, reaction: newReaction },\n          });\n          commentEvents.emit(\"reaction:added\", {\n            commentId,\n            reaction: newReaction,\n            user: currentUser,\n          });\n        }\n\n        const updatedComments = state.comments.map((c) => {\n          if (c.id === commentId) {\n            const reactions = existingReaction\n              ? c.reactions.filter((r) => r.id !== existingReaction.id)\n              : [\n                  ...c.reactions,\n                  {\n                    id: generateId(),\n                    userId: currentUser.id,\n                    type: reactionType as CommentReaction['type'],\n                    createdAt: new Date(),\n                  },\n                ];\n            return { ...c, reactions };\n          }\n          return c;\n        });\n\n        await adapter.saveComments(updatedComments);\n      } catch (error) {\n        // The `error` variable is a placeholder for the actual implementation.\n        if (error) {\n          // do nothing\n        }\n        const errorMessage = \"Failed to add reaction\";\n        dispatch({ type: \"SET_ERROR\", payload: errorMessage });\n        commentEvents.emit(\"error\", {\n          error: errorMessage,\n          action: \"reaction\",\n        });\n      }\n    },\n    [currentUser, state.comments, adapter]\n  );\n\n  const removeReaction = useCallback(\n    async (commentId: string, reactionId: string) => {\n      if (!currentUser) return;\n\n      try {\n        dispatch({\n          type: \"REMOVE_REACTION\",\n          payload: { commentId, reactionId },\n        });\n\n        const updatedComments = state.comments.map((c) => {\n          if (c.id === commentId) {\n            return {\n              ...c,\n              reactions: c.reactions.filter((r) => r.id !== reactionId),\n            };\n          }\n          return c;\n        });\n\n        await adapter.saveComments(updatedComments);\n\n        commentEvents.emit(\"reaction:removed\", {\n          commentId,\n          reactionId,\n          user: currentUser,\n        });\n      } catch (error) {\n        // The `error` variable is a placeholder for the actual implementation.\n        if (error) {\n          // do nothing\n        }\n        const errorMessage = \"Failed to remove reaction\";\n        dispatch({ type: \"SET_ERROR\", payload: errorMessage });\n        commentEvents.emit(\"error\", {\n          error: errorMessage,\n          action: \"reaction\",\n        });\n      }\n    },\n    [state.comments, adapter, currentUser]\n  );\n\n  const getCommentThreads = useCallback(\n    async (\n      sourceId?: string,\n      sourceType?: string\n    ): Promise<CommentThread[]> => {\n      return await adapter.getCommentThreads(sourceId, sourceType);\n    },\n    [adapter]\n  );\n\n  const getcommentsSource = useCallback(\n    (sourceId: string, sourceType?: string): Comment[] => {\n      const topLevelComments = state.comments.filter(\n        (comment) =>\n          comment.sourceId === sourceId &&\n          (!sourceType || comment.sourceType === sourceType) &&\n          !comment.parentId\n      );\n      debug.log(\n        \"getcommentsSource found\",\n        topLevelComments.length,\n        \"top-level comments for sourceId:\",\n        sourceId,\n        \"sourceType:\",\n        sourceType\n      );\n      return topLevelComments;\n    },\n    [state.comments, debug]\n  );\n\n  const getRepliesForComment = useCallback(\n    (parentId: string): Comment[] => {\n      const replies = state.comments.filter(\n        (comment) => comment.parentId === parentId\n      );\n      debug.log(\n        \"getRepliesForComment found\",\n        replies.length,\n        \"replies for parentId:\",\n        parentId\n      );\n      return replies;\n    },\n    [state.comments, debug]\n  );\n\n  const refreshData = useCallback(async () => {\n    dispatch({ type: \"SET_LOADING\", payload: true });\n    try {\n      const comments = await adapter.getComments();\n\n      dispatch({ type: \"LOAD_COMMENTS\", payload: comments });\n      commentEvents.emit(\"comments:loaded\", { comments });\n    } catch (error) {\n      // The `error` variable is a placeholder for the actual implementation.\n      if (error) {\n        // do nothing\n      }\n      const errorMessage = \"Failed to refresh data\";\n      dispatch({ type: \"SET_ERROR\", payload: errorMessage });\n      commentEvents.emit(\"error\", { error: errorMessage, action: \"refresh\" });\n    }\n  }, [adapter]);\n\n  const clearAllStorage = useCallback(async () => {\n    if (!currentUser) return;\n\n    try {\n      await adapter.clearAllStorage();\n      dispatch({ type: \"LOAD_COMMENTS\", payload: [] });\n      commentEvents.emit(\"comments:cleared\", { user: currentUser });\n      debug.log(\"Storage cleared successfully\");\n    } catch (error) {\n      // The `error` variable is a placeholder for the actual implementation.\n      if (error) {\n        // do nothing\n      }\n      debug.error(\"Error clearing storage:\", error);\n      const errorMessage = \"Failed to clear storage\";\n      dispatch({ type: \"SET_ERROR\", payload: errorMessage });\n      commentEvents.emit(\"error\", { error: errorMessage, action: \"clear\" });\n    }\n  }, [adapter, currentUser, debug]);\n\n  const contextValue: CommentContextType = {\n    state,\n    currentUser,\n    config: currentConfig,\n    events: commentEvents,\n    hooks: hookRegistry,\n    addComment,\n    updateComment,\n    deleteComment,\n    addReaction,\n    removeReaction,\n    getCommentThreads,\n    getcommentsSource,\n    getRepliesForComment,\n    refreshData,\n    updateConfig,\n    clearAllStorage,\n  };\n\n  return (\n    <CommentContext.Provider value={contextValue}>\n      {children}\n    </CommentContext.Provider>\n  );\n}\n\n// Hook to use comment context\nexport function useComments() {\n  const context = useContext(CommentContext);\n  if (context === undefined) {\n    throw new Error(\"useComments must be used within a CommentProvider\");\n  }\n  return context;\n}\n"
    },
    {
      "type": "registry:lib",
      "path": "lib/contexts/mention-context.tsx",
      "content": "\"use client\"\n\nimport type React from \"react\"\nimport { createContext, useContext, useState, useEffect, useCallback } from \"react\"\nimport { debug } from \"@/lib/comments/utils/debug\"\nimport { BeautifulMentionsItem } from 'lexical-beautiful-mentions'\n\ntype MentionItemUser = BeautifulMentionsItem & {\n  email?: string\n  avatar?: string\n  role?: string\n}\n\ntype MentionItemTag = BeautifulMentionsItem & {\n  description?: string\n  type: \"resource\" | \"rule\" | \"section\" | \"question\"\n  url?: string\n}\n\ntype MentionItems = {\n  \"@\": MentionItemUser[]\n  \"#\": MentionItemTag[]\n}\n\ninterface MentionContextType {\n  mentionItems: MentionItems\n  loading: boolean\n  error: string | null\n  refreshMentions: () => Promise<void>\n}\n\nconst MentionContext = createContext<MentionContextType | undefined>(undefined)\n\ninterface MentionProviderProps {\n  children: React.ReactNode\n  initialUsers?: MentionItemUser[]\n  initialTags?: MentionItemTag[]\n  getUsersCallback?: () => Promise<MentionItemUser[]>\n  getTagsCallback?: () => Promise<MentionItemTag[]>\n}\n\nexport function MentionProvider({ children, initialUsers, initialTags, getUsersCallback, getTagsCallback }: MentionProviderProps) {\n  const [mentionItems, setMentionItems] = useState<MentionItems>({\n    \"@\": initialUsers || [],\n    \"#\": initialTags || [],\n  })\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n\n  const loadMentionItems = useCallback(async () => {\n    if (initialUsers && initialTags) {\n      debug.log(\"Using provided initial mention data, skipping loadMentionItems\")\n      return\n    }\n\n    setLoading(true)\n    setError(null)\n\n    try {\n      const [users, tags] = await Promise.all([\n        initialUsers ? Promise.resolve(initialUsers) : getUsersCallback ? getUsersCallback() : Promise.resolve([]),\n        initialTags ? Promise.resolve(initialTags) : getTagsCallback ? getTagsCallback() : Promise.resolve([]),\n      ])\n\n      setMentionItems({ \"@\": users, \"#\": tags })\n      debug.log(\"Mention items loaded:\", { userCount: users.length, tagCount: tags.length })\n    } catch (err) {\n      debug.error(\"Failed to load mention items:\", err)\n      setError(\"Failed to load mention data\")\n    } finally {\n      setLoading(false)\n    }\n  }, [initialUsers, initialTags, getUsersCallback, getTagsCallback])\n\n  useEffect(() => {\n    loadMentionItems()\n  }, [loadMentionItems])\n\n  const refreshMentions = useCallback(async () => {\n    await loadMentionItems()\n  }, [loadMentionItems])\n\n  const contextValue: MentionContextType = {\n    mentionItems,\n    loading,\n    error,\n    refreshMentions,\n  }\n\n  return <MentionContext.Provider value={contextValue}>{children}</MentionContext.Provider>\n}\n\nexport function useMentions() {\n  const context = useContext(MentionContext)\n  if (context === undefined) {\n    throw new Error(\"useMentions must be used within a MentionProvider\")\n  }\n  return context\n}\n\nexport type { MentionItemUser as MentionUser, MentionItemTag as MentionTag, MentionItems }\n"
    },
    {
      "type": "registry:hook",
      "path": "lib/hooks/use-comment-actions.ts",
      "content": "\"use client\";\n\nimport { useCallback, useState, useTransition } from \"react\";\nimport { debug } from \"@/lib/comments/utils/debug\";\nimport { useComments } from \"@/lib/comments/contexts/comment-context\";\nimport { toast } from \"sonner\";\nimport type { Comment } from \"@/lib/comments/types/comments\";\n\nexport function useCommentActions() {\n  const {\n    addComment,\n    updateComment,\n    deleteComment,\n    addReaction,\n    removeReaction,\n    currentUser,\n    getRepliesForComment,\n    state,\n    config,\n  } = useComments();\n\n  // The `removeReaction` and `getRepliesForComment` props are passed for consistency with other variants,\n  // but are not used in this component.\n  if (removeReaction && getRepliesForComment) {\n    // do nothing\n  }\n\n  const [isPending, startTransition] = useTransition();\n  const [replyingTo, setReplyingTo] = useState<string | null>(null);\n  const [showComposer, setShowComposer] = useState(false);\n  const [replyContext, setReplyContext] = useState<{\n    commentId: string;\n    authorName: string;\n  } | null>(null);\n\n  const findRootParent = useCallback(\n    (commentId: string, comments: Comment[]): string => {\n      const comment = comments.find((c) => c.id === commentId);\n      if (!comment) {\n        return commentId;\n      }\n\n      // If this comment has no parent, it's already the root\n      if (!comment.parentId) {\n        return commentId;\n      }\n\n      // Traverse up the parent chain to find the root\n      let currentComment = comment;\n      while (currentComment.parentId) {\n        const parentComment = comments.find(\n          (c) => c.id === currentComment.parentId\n        );\n        if (!parentComment) {\n          break;\n        }\n        currentComment = parentComment;\n      }\n\n      return currentComment.id;\n    },\n    []\n  );\n\n  const handleAddComment = useCallback(\n    async (\n      content: string,\n      editorState: string,\n      sourceId?: string,\n      sourceType?: string,\n      parentId?: string\n    ) => {\n      startTransition(async () => {\n        try {\n          await addComment(content, editorState, sourceId, sourceType, parentId);\n          if (!config.hideToast) {\n            toast.success(\"Your comment has been posted successfully.\");\n          }\n          setShowComposer(false);\n        } catch (error) {\n          // The `error` variable is a placeholder for the actual implementation.\n          if (error) {\n            // do nothing\n          }\n          if (!config.hideToast) {\n            toast.error(\"Failed to add comment. Please try again.\");\n          }\n        }\n      });\n    },\n    [addComment, config.hideToast]\n  );\n\n  const handleUpdateComment = useCallback(\n    async (commentId: string, content: string, editorState: string) => {\n      startTransition(async () => {\n        try {\n          await updateComment(commentId, content, editorState);\n          if (!config.hideToast) {\n            toast.success(\"Your comment has been updated successfully.\");\n          }\n        } catch (error) {\n          // The `error` variable is a placeholder for the actual implementation.\n          if (error) {\n            // do nothing\n          }\n          if (!config.hideToast) {\n            toast.error(\"Failed to update comment. Please try again.\");\n          }\n        }\n      });\n    },\n    [updateComment, config.hideToast]\n  );\n\n  const handleDeleteComment = useCallback(\n    async (commentId: string) => {\n      startTransition(async () => {\n        try {\n          await deleteComment(commentId);\n          if (!config.hideToast) {\n            toast.success(\"The comment has been deleted successfully.\");\n          }\n        } catch (error) {\n          // The `error` variable is a placeholder for the actual implementation.\n          if (error) {\n            // do nothing\n          }\n          if (!config.hideToast) {\n            toast.error(\"Failed to delete comment. Please try again.\");\n          }\n        }\n      });\n    },\n    [deleteComment, config.hideToast]\n  );\n\n  const handleReaction = useCallback(\n    async (commentId: string, reactionType: string) => {\n      startTransition(async () => {\n        try {\n          await addReaction(commentId, reactionType);\n        } catch (error) {\n          // The `error` variable is a placeholder for the actual implementation.\n          if (error) {\n            // do nothing\n          }\n          if (!config.hideToast) {\n            toast.error(\"Failed to add reaction. Please try again.\");\n          }\n        }\n      });\n    },\n    [addReaction, config.hideToast]\n  );\n\n  const handleStartReply = useCallback(\n    (commentId: string) => {\n      const comment = state.comments.find((c) => c.id === commentId);\n      if (comment) {\n        setReplyContext({\n          commentId,\n          authorName: comment.author.name,\n        });\n      }\n      setReplyingTo(commentId);\n    },\n    [state.comments]\n  );\n\n  const handleCancelReply = useCallback(() => {\n    setReplyingTo(null);\n    setReplyContext(null);\n  }, []);\n\n  const handleReplySubmit = useCallback(\n    async (\n      content: string,\n      editorState: string,\n      replyToId: string,\n      comments: Comment[]\n    ) => {\n      const rootParentId = findRootParent(replyToId, comments);\n      const parentComment = comments.find((c) => c.id === rootParentId);\n\n      // Inherit source information from parent comment\n      const sourceId = parentComment?.sourceId;\n      const sourceType = parentComment?.sourceType;\n\n      debug.log(\n        \"Reply submission - parentId:\",\n        rootParentId,\n        \"sourceId:\",\n        sourceId,\n        \"sourceType:\",\n        sourceType\n      );\n\n      await handleAddComment(\n        content,\n        editorState,\n        sourceId,\n        sourceType,\n        rootParentId\n      );\n      setReplyingTo(null);\n      setReplyContext(null);\n    },\n    [handleAddComment, findRootParent]\n  );\n\n  const handleReply = useCallback(\n    async (content: string, editorState: string, parentId: string) => {\n      startTransition(async () => {\n        try {\n          const rootParentId = findRootParent(parentId, state.comments);\n          const parentComment = state.comments.find(\n            (c) => c.id === rootParentId\n          );\n\n          // Inherit source information from root parent comment\n          const sourceId = parentComment?.sourceId;\n          const sourceType = parentComment?.sourceType;\n\n          debug.log(\n            \"Reply submission - parentId:\",\n            rootParentId,\n            \"sourceId:\",\n            sourceId,\n            \"sourceType:\",\n            sourceType\n          );\n\n          await addComment(\n            content,\n            editorState,\n            sourceId,\n            sourceType,\n            rootParentId\n          );\n          if (!config.hideToast) {\n            toast.success(\"Your reply has been posted successfully.\");\n          }\n        } catch (error) {\n          // The `error` variable is a placeholder for the actual implementation.\n          if (error) {\n            // do nothing\n          }\n          if (!config.hideToast) {\n            toast.error(\"Failed to add reply. Please try again.\");\n          }\n        }\n      });\n    },\n    [addComment, state.comments, findRootParent, config.hideToast]\n  );\n\n  const handleToggleComposer = useCallback(() => {\n    setShowComposer(!showComposer);\n  }, [showComposer]);\n\n  const handleCommentSubmit = useCallback(\n    async (\n      content: string,\n      editorState: string,\n      sourceId?: string,\n      sourceType?: string\n    ) => {\n      await handleAddComment(content, editorState, sourceId, sourceType);\n    },\n    [handleAddComment]\n  );\n\n  const handleLike = useCallback(\n    (commentId: string) => handleReaction(commentId, \"like\"),\n    [handleReaction]\n  );\n  const handleShare = useCallback(\n    (commentId: string) =>\n      debug.log(\"Share clicked for comment:\", commentId),\n    []\n  );\n  const handleForward = useCallback(\n    (commentId: string) =>\n      debug.log(\"Forward clicked for comment:\", commentId),\n    []\n  );\n  const handleApprove = useCallback(\n    (commentId: string) =>\n      debug.log(\"Approve clicked for comment:\", commentId),\n    []\n  );\n  const handleReact = useCallback(\n    (commentId: string, reaction: string) => handleReaction(commentId, reaction),\n    [handleReaction]\n  );\n\n  return {\n    // Core actions with loading states\n    handleAddComment,\n    handleUpdateComment,\n    handleDeleteComment,\n    handleReaction,\n\n    // Reply management\n    handleStartReply,\n    handleCancelReply,\n    handleReplySubmit,\n    handleReply, // Added handleReply to exports\n    replyingTo,\n    replyContext,\n\n    // Composer management\n    handleToggleComposer,\n    handleCommentSubmit,\n    showComposer,\n\n    // Variant-specific actions\n    handleLike,\n    handleShare,\n    handleForward,\n    handleApprove,\n    handleReact,\n\n    // Utilities\n    findRootParent,\n    currentUser,\n    isPending,\n  };\n}\n"
    },
    {
      "type": "registry:hook",
      "path": "lib/hooks/use-comment-config.ts",
      "content": "\"use client\"\n\nimport { useState, useCallback } from \"react\"\n\n// Configuration interfaces for editor features\nexport interface EditorFeatures {\n  lists?: boolean\n  checkLists?: boolean\n  autoLink?: boolean\n  mentions?: boolean\n  emoji?: boolean\n  autoList?: boolean\n}\n\nexport interface CommentConfig {\n  hideToast?: boolean\n  debug?: boolean\n  editorFeatures?: EditorFeatures\n  placeholder?: string\n  variant?:\n    | \"card\"\n    | \"bubble\"\n    | \"timeline\"\n    | \"compact\"\n    | \"plain\"\n    | \"social\"\n    | \"professional\"\n    | \"clean\"\n    | \"thread\"\n    | \"github\"\n    | \"email\"\n    | \"notion\"\n    | \"mobile\"\n}\n\n// Default configuration\nconst defaultConfig: CommentConfig = {\n  hideToast: false,\n  debug: false,\n  editorFeatures: {\n    lists: true,\n    checkLists: true,\n    autoLink: true,\n    mentions: true,\n    emoji: true,\n    autoList: true,\n  },\n  placeholder: \"Add a comment ...\",\n  variant: \"card\",\n}\n\nexport function useCommentConfig(initialConfig?: CommentConfig) {\n  const [currentConfig, setCurrentConfig] = useState<CommentConfig>({\n    ...defaultConfig,\n    ...initialConfig,\n    editorFeatures: {\n      ...defaultConfig.editorFeatures,\n      ...initialConfig?.editorFeatures,\n    },\n  })\n\n  const updateConfig = useCallback((newConfig: Partial<CommentConfig>) => {\n    console.log(\"updating config!!\", newConfig)\n    setCurrentConfig((prev) => ({\n      ...prev,\n      ...newConfig,\n      editorFeatures: {\n        ...prev.editorFeatures,\n        ...newConfig.editorFeatures,\n      },\n    }))\n  }, [])\n\n  return {\n    config: currentConfig,\n    updateConfig,\n  }\n}\n\n// Debug logging utility\nexport function createDebugLogger(config: CommentConfig) {\n  return {\n    log: (...args: any[]) => {\n      if (config.debug) {\n        console.log(\"[FARGO]\", ...args)\n      }\n    },\n    error: (...args: any[]) => {\n      if (config.debug) {\n        console.error(\"[FARGO]\", ...args)\n      }\n    },\n    warn: (...args: any[]) => {\n      if (config.debug) {\n        console.warn(\"[FARGO]\", ...args)\n      }\n    }\n  }\n}\n"
    },
    {
      "type": "registry:hook",
      "path": "lib/hooks/use-comment-context-hooks.ts",
      "content": "\"use client\"\n\nimport { useState, useMemo, useCallback } from \"react\"\nimport { debug } from \"@/lib/comments/utils/debug\"\nimport type { CommentHooks, CommentHookRegistry, CommentHookContext } from \"@/lib/comments/types/comment-hooks\"\nimport type { User } from \"@/lib/comments/types/comments\"\nimport type { CommentConfig } from \"@/hooks/use-comment-config\"\nimport type { CommentState } from \"@/lib/comments/reducers/comment-reducer\"\nimport type { CommentEventEmitter } from \"@/lib/comments/comment-events\"\n\ninterface UseCommentContextHooksProps {\n  initialHooks?: Partial<CommentHooks>\n  currentUser: User | null\n  config: CommentConfig\n  state: CommentState\n  events: CommentEventEmitter\n}\n\nexport function useCommentContextHooks({\n  initialHooks,\n  currentUser,\n  config,\n  state,\n  events,\n}: UseCommentContextHooksProps) {\n  const [registeredHooks, setRegisteredHooks] = useState<CommentHooks>(() => {\n    const hooks: CommentHooks = {}\n    if (initialHooks) {\n      Object.entries(initialHooks).forEach(([key, callbacks]) => {\n        if (callbacks) {\n          hooks[key as keyof CommentHooks] = Array.isArray(callbacks) ? callbacks : [callbacks]\n        }\n      })\n    }\n    return hooks\n  })\n\n  const createHookContext = useCallback((): CommentHookContext => {\n    return {\n      currentUser,\n      config,\n      existingComments: state.comments,\n    }\n  }, [currentUser, config, state.comments])\n\n  const hookRegistry: CommentHookRegistry = useMemo(\n    () => ({\n      registerHook: (hookName, callback) => {\n        setRegisteredHooks((prev) => ({\n          ...prev,\n          [hookName]: [...(prev[hookName] || []), callback],\n        }))\n        return () => {\n          setRegisteredHooks((prev) => ({\n            ...prev,\n            [hookName]: (prev[hookName] || []).filter((cb) => cb !== callback),\n          }))\n        }\n      },\n      unregisterHook: (hookName, callback) => {\n        setRegisteredHooks((prev) => ({\n          ...prev,\n          [hookName]: (prev[hookName] || []).filter((cb) => cb !== callback),\n        }))\n      },\n      executeHooks: async (hookName, data, context) => {\n        const hooks = registeredHooks[hookName] || []\n        let result = data\n\n        for (const hook of hooks) {\n          try {\n            const hookResult = await hook(result, context)\n            if (hookResult && typeof hookResult === \"object\") {\n              result = { ...result, ...hookResult }\n            }\n          } catch (error) {\n            debug.error(`Hook ${hookName} failed:`, error)\n            events.emit(\"error\", {\n              error: `Hook ${hookName} failed: ${error}`,\n              action: \"hook\",\n            })\n          }\n        }\n\n        return result\n      },\n    }),\n    [registeredHooks, events],\n  )\n\n  return {\n    hookRegistry,\n    createHookContext,\n  }\n}\n"
    },
    {
      "type": "registry:hook",
      "path": "lib/hooks/use-comments-from-source.ts",
      "content": "\"use client\"\n\nimport { useMemo } from \"react\"\nimport { useComments } from \"@/lib/comments/contexts/comment-context\"\n\nexport function useCommentsFromSource(sourceId: string, sourceType?: string) {\n  const { state, getcommentsSource } = useComments()\n\n  const comments = useMemo(() => {\n    return getcommentsSource(sourceId, sourceType)\n  }, [getcommentsSource, sourceId, sourceType])\n\n  const commentStats = useMemo(() => {\n    const unresolvedComments = comments.filter((comment) => !comment.reactions.some((r) => r.type === \"resolved\"))\n\n    return {\n      totalComments: comments.length,\n      unresolvedCount: unresolvedComments.length,\n      hasComments: comments.length > 0,\n      hasUnresolved: unresolvedComments.length > 0,\n    }\n  }, [comments])\n\n  return {\n    comments,\n    ...commentStats,\n    loading: state.loading,\n    error: state.error,\n  }\n}\n"
    },
    {
      "type": "registry:lib",
      "path": "lib/lexical-utils.ts",
      "content": "import { debug } from \"@/lib/comments/utils/debug\"\n\nexport interface ExtractedMention {\n  value: string\n  [key: string]: string | number | boolean | undefined\n}\n\nexport interface ExtractedTag {\n  value: string\n  [key: string]: string | number | boolean | undefined\n}\n\ninterface LexicalNode {\n  type: string\n  value?: string\n  data?: Record<string, unknown>\n  trigger?: string\n  children?: LexicalNode[]\n}\n\nexport function extractMentionsAndTags(editorState: string): {\n  mentions: ExtractedMention[]\n  tags: ExtractedTag[]\n} {\n  try {\n    const parsed: { root: LexicalNode } = JSON.parse(editorState)\n    const mentions: ExtractedMention[] = []\n    const tags: ExtractedTag[] = []\n\n    function traverseNodes(node: LexicalNode) {\n      if (node.type === \"custom-beautifulMention\") {\n        const flattened = {\n          value: node.value,\n          ...(node.data || {}),\n        }\n\n        if (node.trigger === \"@\") {\n          mentions.push(flattened as ExtractedMention)\n        } else if (node.trigger === \"#\") {\n          tags.push(flattened as ExtractedTag)\n        }\n      }\n\n      if (node.children && Array.isArray(node.children)) {\n        node.children.forEach(traverseNodes)\n      }\n    }\n\n    traverseNodes(parsed.root)\n    return { mentions, tags }\n  } catch (error) {\n    debug.error(\"Error extracting mentions/tags from editorState:\", error)\n    return { mentions: [], tags: [] }\n  }\n}\n"
    },
    {
      "type": "registry:lib",
      "path": "lib/reducers/comment-reducer.ts",
      "content": "import type { Comment, CommentReaction } from \"@/lib/comments/types/comments\";\n\n// Action types for comment reducer\nexport type CommentAction =\n  | { type: \"LOAD_COMMENTS\"; payload: Comment[] }\n  | { type: \"ADD_COMMENT\"; payload: Comment }\n  | { type: \"UPDATE_COMMENT\"; payload: { id: string; updates: Partial<Comment> } }\n  | { type: \"DELETE_COMMENT\"; payload: string }\n  | { type: \"ADD_REACTION\"; payload: { commentId: string; reaction: CommentReaction } }\n  | { type: \"REMOVE_REACTION\"; payload: { commentId: string; reactionId: string } }\n  | { type: \"SET_LOADING\"; payload: boolean }\n  | { type: \"SET_ERROR\"; payload: string | null }\n\n// Comment state interface\nexport interface CommentState {\n  comments: Comment[]\n  loading: boolean\n  error: string | null\n}\n\n// Initial state\nexport const initialCommentState: CommentState = {\n  comments: [],\n  loading: false,\n  error: null,\n}\n\n// Comment reducer\nexport function commentReducer(state: CommentState, action: CommentAction): CommentState {\n  switch (action.type) {\n    case \"LOAD_COMMENTS\":\n      return {\n        ...state,\n        comments: action.payload,\n        loading: false,\n        error: null,\n      }\n\n    case \"ADD_COMMENT\":\n      return {\n        ...state,\n        comments: [...state.comments, action.payload],\n        error: null,\n      }\n\n    case \"UPDATE_COMMENT\":\n      return {\n        ...state,\n        comments: state.comments.map((comment) =>\n          comment.id === action.payload.id\n            ? { ...comment, ...action.payload.updates, isEdited: true, updatedAt: new Date() }\n            : comment,\n        ),\n        error: null,\n      }\n\n    case \"DELETE_COMMENT\":\n      return {\n        ...state,\n        comments: state.comments.filter((comment) => comment.id !== action.payload),\n        error: null,\n      }\n\n    case \"ADD_REACTION\":\n      return {\n        ...state,\n        comments: state.comments.map((comment) =>\n          comment.id === action.payload.commentId\n            ? {\n                ...comment,\n                reactions: [...comment.reactions, action.payload.reaction],\n              }\n            : comment,\n        ),\n        error: null,\n      }\n\n    case \"REMOVE_REACTION\":\n      return {\n        ...state,\n        comments: state.comments.map((comment) =>\n          comment.id === action.payload.commentId\n            ? {\n                ...comment,\n                reactions: comment.reactions.filter((r) => r.id !== action.payload.reactionId),\n              }\n            : comment,\n        ),\n        error: null,\n      }\n\n    case \"SET_LOADING\":\n      return {\n        ...state,\n        loading: action.payload,\n      }\n\n    case \"SET_ERROR\":\n      return {\n        ...state,\n        error: action.payload,\n        loading: false,\n      }\n\n    default:\n      return state\n  }\n}\n"
    },
    {
      "type": "registry:lib",
      "path": "lib/types/comment-hooks.ts",
      "content": "import type { Comment, User, MentionUser, MentionTag } from \"@/lib/comments/types/comments\"\nimport type { CommentConfig } from \"@/lib/comments/hooks/use-comment-config\"\n\n// Hook context provided to all hook callbacks\nexport interface CommentHookContext {\n  currentUser: User | null\n  config: CommentConfig\n  existingComments: Comment[]\n}\n\n// Hook callback types for different operations\nexport interface AddCommentHookData {\n  content: string\n  editorState: string\n  mentions: MentionUser[]\n  tags: MentionTag[]\n  sourceId?: string\n  sourceType?: string\n  parentId?: string\n  user: User\n}\n\nexport interface UpdateCommentHookData {\n  commentId: string\n  content: string\n  editorState: string\n  mentions: MentionUser[]\n  tags: MentionTag[]\n  existingComment: Comment\n}\n\nexport interface CommentHookData {\n  comment: Comment\n}\n\n// Hook callback function types\nexport type AddCommentHook = (\n  data: AddCommentHookData,\n  context: CommentHookContext,\n) => Promise<Partial<AddCommentHookData>> | Partial<AddCommentHookData>\n\nexport type UpdateCommentHook = (\n  data: UpdateCommentHookData,\n  context: CommentHookContext,\n) => Promise<Partial<UpdateCommentHookData>> | Partial<UpdateCommentHookData>\n\nexport type PreSaveCommentHook = (\n  data: CommentHookData,\n  context: CommentHookContext,\n) => Promise<Partial<Comment>> | Partial<Comment>\n\nexport type PostSaveCommentHook = (data: CommentHookData, context: CommentHookContext) => Promise<void> | void\n\n// Hook registry interface\nexport interface CommentHooks {\n  beforeAddComment?: AddCommentHook[]\n  afterAddComment?: PostSaveCommentHook[]\n  beforeUpdateComment?: UpdateCommentHook[]\n  afterUpdateComment?: PostSaveCommentHook[]\n  beforeSaveComment?: PreSaveCommentHook[]\n  afterSaveComment?: PostSaveCommentHook[]\n}\n\n// Hook registration methods\nexport interface CommentHookRegistry {\n  registerHook: <T extends keyof CommentHooks>(hookName: T, callback: NonNullable<CommentHooks[T]>[0]) => () => void\n  unregisterHook: <T extends keyof CommentHooks>(hookName: T, callback: NonNullable<CommentHooks[T]>[0]) => void\n  executeHooks: <T extends keyof CommentHooks>(\n    hookName: T,\n    data: Parameters<NonNullable<CommentHooks[T]>[0]>[0],\n    context: CommentHookContext,\n  ) => Promise<Parameters<NonNullable<CommentHooks[T]>[0]>[0]>\n}\n"
    },
    {
      "type": "registry:lib",
      "path": "lib/types/comments.ts",
      "content": "// Core comment system types - generic and reusable\nexport interface User {\n  id: string;\n  name: string;\n  email: string;\n  avatar?: string;\n  role: \"auditor\" | \"reviewer\" | \"admin\" | \"client\";\n  createdAt: Date;\n}\n\nexport type ContentType = \"resource\" | \"rule\" | \"section\" | \"question\";\n\nexport interface SourceReference {\n  id: string;\n  url: string;\n  elementId?: string; // DOM element ID or selector\n  label: string;\n  description?: string;\n  type: ContentType | \"document\" | \"regulation\" | \"external_link\" | \"image\";\n  metadata?: {\n    pageTitle?: string;\n    sectionName?: string;\n    coordinates?: { x: number; y: number };\n    timestamp?: Date;\n  };\n}\n\nexport interface MentionUser {\n  id: string;\n  type: \"user\";\n  userId: string;\n  user: User;\n  startIndex: number;\n  endIndex: number;\n  displayText: string; // e.g., \"@greg\"\n}\n\nexport interface MentionTag {\n  id: string;\n  type: ContentType;\n  resourceId: string;\n  label: string; // e.g., \"Q1.5.3\", \"rule3.1.3\"\n  description?: string;\n  url?: string;\n  startIndex: number;\n  endIndex: number;\n  displayText: string; // e.g., \"#Q1.5.3\"\n}\n\nexport interface Comment {\n  id: string;\n  content: string;\n  editorState?: string; // Lexical editor state as JSON string\n  authorId: string;\n  author: User;\n  sourceId?: string; // Generic source association\n  sourceType?: string; // Type of source (audit, project, document, etc.)\n  parentId?: string; // For nested replies\n  sourceReference?: SourceReference; // Added source reference to comments\n  mentions: MentionUser[]; // Parsed @mentions in comment\n  tags: MentionTag[]; // Parsed #tags in comment\n  createdAt: Date;\n  updatedAt: Date;\n  isEdited: boolean;\n  reactions: CommentReaction[];\n  status: \"active\" | \"deleted\" | \"hidden\";\n}\n\nexport interface CommentReaction {\n  id: string;\n  userId: string;\n  type: \"like\" | \"approve\" | \"concern\" | \"resolved\";\n  createdAt: Date;\n}\n\nexport interface CommentThread {\n  id: string;\n  rootComment: Comment;\n  replies: Comment[];\n  totalReplies: number;\n  lastActivity: Date;\n}\n\n// Comment system configuration\nexport interface CommentSystemConfig {\n  allowAnonymous: boolean;\n  requireApproval: boolean;\n  maxNestingLevel: number;\n  allowReactions: boolean;\n  mentionsEnabled: boolean;\n}\n\nexport type CommentVariant =\n  | \"card\"\n  | \"bubble\"\n  | \"timeline\"\n  | \"compact\"\n  | \"plain\"\n  | \"social\"\n  | \"professional\"\n  | \"clean\"\n  | \"thread\"\n  | \"github\"\n  | \"email\"\n  | \"notion\"\n  | \"mobile\"\n  | \"inline\"\n"
    },
    {
      "type": "registry:lib",
      "path": "lib/utils/debug.ts",
      "content": "// Debug utility for lib/comments\n// Since individual plugins/components don't have direct access to config,\n// we'll provide a simple debug utility they can use\n\nlet isDebugEnabled = false;\n\nexport function setDebugMode(enabled: boolean) {\n  isDebugEnabled = enabled;\n}\n\nexport const debug = {\n  log: (...args: any[]) => {\n    if (isDebugEnabled) {\n      console.log(\"[FARGO]\", ...args);\n    }\n  },\n  error: (...args: any[]) => {\n    if (isDebugEnabled) {\n      console.error(\"[FARGO]\", ...args);\n    }\n  },\n  warn: (...args: any[]) => {\n    if (isDebugEnabled) {\n      console.warn(\"[FARGO]\", ...args);\n    }\n  },\n};"
    },
    {
      "type": "registry:lib",
      "path": "lib/utils/formatTimeAgo.ts",
      "content": "/**\n * Formats a date into a human-readable \"time ago\" string.\n *\n * @param date - The date to format\n * @returns A formatted string representing the time elapsed since the given date:\n *   - \"just now\" for times less than 1 minute ago\n *   - \"Xm ago\" for times less than 1 hour ago\n *   - \"Xh ago\" for times less than 1 day ago\n *   - \"Xd ago\" for times less than 1 week ago\n *   - Localized date string for times 1 week or older\n *\n * @example\n * ```typescript\n * const now = new Date();\n * const fiveMinutesAgo = new Date(now.getTime() - 5 * 60 * 1000);\n * formatTimeAgo(fiveMinutesAgo); // \"5m ago\"\n * ```\n */\n\nexport function formatTimeAgo(date: Date): string {\n  const now = new Date();\n  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);\n\n  if (diffInSeconds < 60) return \"just now\";\n  if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;\n  if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;\n  if (diffInSeconds < 604800)\n    return `${Math.floor(diffInSeconds / 86400)}d ago`;\n\n  return date.toLocaleDateString();\n}\n"
    },
    {
      "type": "registry:lib",
      "path": "lib/utils/generateId.ts",
      "content": "/**\n * Generates a unique identifier string by combining a random string with a timestamp.\n *\n * The function creates an ID by concatenating:\n * - A random string (base36 encoded) with the first 2 characters removed\n * - The current timestamp converted to base36\n *\n * @returns A unique string identifier\n *\n * @example\n * ```typescript\n * const id = generateId();\n * console.log(id); // Example output: \"k3j2m1p8xz9\"\n * ```\n */\n\nexport function generateId(): string {\n  return Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n"
    }
  ]
}
