{
  "name": "fargo-comments-adapter-tanstack-query",
  "type": "registry:lib",
  "dependencies": [
    "@emoji-mart/data@latest",
    "@lexical/link@latest",
    "@lexical/list@latest",
    "@lexical/react@latest",
    "@lexical/utils@latest",
    "class-variance-authority@^0.7.1",
    "clsx@^2.1.1",
    "date-fns@4.1.0",
    "emoji-mart@latest",
    "lexical@latest",
    "lexical-beautiful-mentions@latest",
    "lucide-react@^0.454.0",
    "tailwind-merge@^2.5.5",
    "@tanstack/react-query@^5.0.0"
  ],
  "registryDependencies": [
    "https://comments.griffen.codes/api/registry/r/core"
  ],
  "files": [
    {
      "type": "registry:lib",
      "path": "lib/adapters/tanstack-query-adapter.ts",
      "content": "import { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\"\nimport type {\n    User,\n    Comment,\n    CommentThread,\n    MentionUser,\n    MentionTag,\n} from \"@/lib/comments/types/comments\"\nimport type {\n    CommentStorageAdapter,\n    StorageAdapterConfig,\n} from \"./comment-storage-adapter\"\n\nexport function useTanstackQueryAdapter(config: StorageAdapterConfig = {}) {\n  const queryClient = useQueryClient()\n  const baseUrl = config.apiEndpoint || \"/api\"\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    ...config.headers,\n  }\n\n  const request = async <T>(\n    endpoint: string,\n    options: RequestInit = {}\n  ): Promise<T> => {\n    const response = await fetch(`${baseUrl}${endpoint}`, {\n      headers,\n      ...options,\n    })\n\n    if (!response.ok) {\n      throw new Error(`API request failed: ${response.statusText}`)\n    }\n\n    return response.json()\n  }\n\n  // Query hooks for data fetching\n  const useComments = () =>\n    useQuery<Comment[]>({\n      queryKey: [\"comments\"],\n      queryFn: () => request<Comment[]>(\"/comments\"),\n      staleTime: 5 * 60 * 1000, // 5 minutes\n    })\n\n  const useCommentThreads = (sourceId?: string, sourceType?: string) =>\n    useQuery<CommentThread[]>({\n      queryKey: [\"comments\", \"threads\", sourceId, sourceType],\n      queryFn: () => {\n        const query = sourceId\n          ? `?sourceId=${sourceId}${\n              sourceType ? `&sourceType=${sourceType}` : \"\"\n            }`\n          : \"\"\n        return request<CommentThread[]>(`/comments/threads${query}`)\n      },\n    })\n\n  const addCommentMutation = useMutation({\n    mutationFn: (comment: Comment) =>\n      request<Comment>(\"/comments\", {\n        method: \"POST\",\n        body: JSON.stringify(comment),\n      }),\n    onMutate: async (newComment) => {\n      await queryClient.cancelQueries({ queryKey: [\"comments\"] })\n      const previousComments = queryClient.getQueryData<Comment[]>([\"comments\"])\n\n      queryClient.setQueryData(\n        [\"comments\"],\n        (old: Comment[] = []) => [...old, newComment]\n      )\n\n      return { previousComments }\n    },\n    onError: (_err, _newComment, context) => {\n      queryClient.setQueryData([\"comments\"], context?.previousComments)\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: [\"comments\"] })\n    },\n  })\n\n  const updateCommentMutation = useMutation({\n    mutationFn: ({\n      commentId,\n      updates,\n    }: {\n      commentId: string\n      updates: Partial<Comment>\n    }) =>\n      request<void>(`/comments/${commentId}`, {\n        method: \"PATCH\",\n        body: JSON.stringify(updates),\n      }),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: [\"comments\"] })\n    },\n  })\n\n  const deleteCommentMutation = useMutation({\n    mutationFn: (commentId: string) =>\n      request<void>(`/comments/${commentId}`, {\n        method: \"DELETE\",\n      }),\n    onMutate: async (deletedId) => {\n      await queryClient.cancelQueries({ queryKey: [\"comments\"] })\n      const previousComments = queryClient.getQueryData<Comment[]>([\"comments\"])\n\n      queryClient.setQueryData(\n        [\"comments\"],\n        (old: Comment[] = []) =>\n          old.filter((comment) => comment.id !== deletedId)\n      )\n\n      return { previousComments }\n    },\n    onError: (_err, _deletedId, context) => {\n      queryClient.setQueryData([\"comments\"], context?.previousComments)\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: [\"comments\"] })\n    },\n  })\n\n  const addLexicalCommentMutation = useMutation({\n    mutationFn: (params: {\n      content: string\n      editorState: string\n      author: User\n      mentions?: MentionUser[]\n      tags?: MentionTag[]\n      sourceId?: string\n      sourceType?: string\n      parentId?: string\n    }) =>\n      request<Comment>(\"/comments/lexical\", {\n        method: \"POST\",\n        body: JSON.stringify(params),\n      }),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: [\"comments\"] })\n    },\n  })\n\n  const adapter: CommentStorageAdapter & {\n    hooks: {\n      useComments: typeof useComments\n      useCommentThreads: typeof useCommentThreads\n    }\n    mutations: {\n      addComment: typeof addCommentMutation\n      updateComment: typeof updateCommentMutation\n      deleteComment: typeof deleteCommentMutation\n      addLexicalComment: typeof addLexicalCommentMutation\n    }\n  } = {\n    // Hook access\n    hooks: {\n      useComments,\n      useCommentThreads,\n    },\n    mutations: {\n      addComment: addCommentMutation,\n      updateComment: updateCommentMutation,\n      deleteComment: deleteCommentMutation,\n      addLexicalComment: addLexicalCommentMutation,\n    },\n\n    // Fallback methods for backward compatibility\n    async getComments(): Promise<Comment[]> {\n      return request<Comment[]>(\"/comments\")\n    },\n\n    async saveComments(comments: Comment[]): Promise<void> {\n      await request<void>(\"/comments/bulk\", {\n        method: \"PUT\",\n        body: JSON.stringify(comments),\n      })\n    },\n\n    async addComment(comment: Comment): Promise<void> {\n      await request<void>(\"/comments\", {\n        method: \"POST\",\n        body: JSON.stringify(comment),\n      })\n    },\n\n    async updateComment(\n      commentId: string,\n      updates: Partial<Comment>\n    ): Promise<void> {\n      await request<void>(`/comments/${commentId}`, {\n        method: \"PATCH\",\n        body: JSON.stringify(updates),\n      })\n    },\n\n    async deleteComment(commentId: string): Promise<void> {\n      await request<void>(`/comments/${commentId}`, {\n        method: \"DELETE\",\n      })\n    },\n\n    async addLexicalComment(\n      content: string,\n      editorState: string,\n      author: User,\n      mentions: MentionUser[] = [],\n      tags: MentionTag[] = [],\n      sourceId?: string,\n      sourceType?: string,\n      parentId?: string\n    ): Promise<Comment> {\n      return request<Comment>(\"/comments/lexical\", {\n        method: \"POST\",\n        body: JSON.stringify({\n          content,\n          editorState,\n          author,\n          mentions,\n          tags,\n          sourceId,\n          sourceType,\n          parentId,\n        }),\n      })\n    },\n\n    async updateCommentWithEditorState(\n      commentId: string,\n      content: string,\n      editorState: string\n    ): Promise<void> {\n      await request<void>(`/comments/${commentId}/lexical`, {\n        method: \"PATCH\",\n        body: JSON.stringify({ content, editorState }),\n      })\n    },\n\n    async getcommentsSource(\n      sourceId: string,\n      sourceType?: string\n    ): Promise<Comment[]> {\n      const query = `?sourceId=${sourceId}${\n        sourceType ? `&sourceType=${sourceType}` : \"\"\n      }`\n      return request<Comment[]>(`/comments${query}`)\n    },\n\n    async getCommentThreads(\n      sourceId?: string,\n      sourceType?: string\n    ): Promise<CommentThread[]> {\n      const query = sourceId\n        ? `?sourceId=${sourceId}${\n            sourceType ? `&sourceType=${sourceType}` : \"\"\n          }`\n        : \"\"\n      return request<CommentThread[]>(`/comments/threads${query}`)\n    },\n\n    async clearAllStorage(): Promise<void> {\n      await request<void>(\"/storage/clear\", { method: \"DELETE\" })\n    },\n  }\n\n  return adapter\n}\n"
    }
  ]
}
